---
title: "ADVANCED R"
author: "M Adi Setiawan"
date: "2023-09-15"
output: html_document
---

> disclaimer : this article adopt from advanced r by Hadley Wickham



# 1. DATA STRCUTURE

There are 3 common data type that be used in data analys framework :

1. Homogenous Data : Atomic Vector, Matrix & n Array

2. Heterogenous Data : List, Data Frame

## 1.1 Vector

Three common properties in vector : 
  * typeof() : what it is
  
  * length() : how many elements it contains
  
  * attributes() : additional arbitrary metadata
  
  > all elements of an atomic vector must be the same type, whereas the elements of a list can have different types.
  
  > NB: is.vector() does not test if an object is a vector. Instead it returns TRUE only if the object is a vector with no attributes apart from names. Use is.atomic(x) || is.list(x) to test if an object is actually a vector.
  
  
### 1.1.1 ATOMIC VECTOR

Atomic vectors are usually created with c(), short for combine:

```{r atomic vector, include=FALSE}
dbl_var <- c(1, 2.5, 4.5)

# With the L suffix, you get an integer rather than a double 
int_var <- c(1L, 6L, 10L)

# Use TRUE and FALSE (or T and F) to create logical vectors 
log_var <- c(TRUE, FALSE, T, F)

chr_var <- c("these are", "some strings")

# Atomic vectors are always flat, even if you nest c()’s:
c(1, c(2, c(3, 4)))

# [1]1234
```


NA will always be coerced to the correct type if used inside c(), or you can create NAs of a specific type with : 

  * NA_real_ (a double vector) 
  * NA_integer_ 
  * NA_character_
  
(you can check through combining it with typeof() function)

### 1.1.1.1 Types and tests

Given a vector, you can determine its type with typeof(), or check if it’s a specific type with an “is” function: is.character(), is.double(), is.integer(), is.logical(), or, more generally, is.atomic().

> is.numeric() is a general test for the “numberliness” of a vector and returns TRUE for both integer and double vectors. It is not a specific test for double vectors, which are often called numeric.

```{r type test, include=FALSE}

typeof(int_var)
is.integer(int_var)
is.atomic(int_var)

typeof(dbl_var)
is.double(dbl_var)
is.atomic(dbl_var)

is.numeric(int_var)
is.numeric(dbl_var)

# NB : Numeric contain 2 type : integer : whole number (ex : 1,10) and double : possibly store decimal (ex : 1.11 , 2.00)

```

### 1.1.1.2 Coercion

All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type.

```{r coercion vector, include=FALSE}

str(c("a", 1))
#>  chr [1:2] "a" "1" : stored as char

```

When a logical vector is coerced to an integer or double, TRUE becomes 1 and FALSE becomes 0. This is very useful in conjunction with sum() and mean().

```{r, include=FALSE}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
str(as.numeric(x))

# so we can apply some basic math operating :

# Total number of TRUEs
sum(x) 
#>[1]1

# Proportion that are TRUE
mean(x)
#> [1] 0.3333

```

Coercion often happens automatically. Most mathematical functions (+, log, abs, etc.) will coerce to a double or integer, and most logical operations (&, |, any, etc) will coerce to a logical. You will usually get a warning message if the coercion might lose information. If confusion is likely, explicitly coerce with as.character(), as.double(), as.integer(), or as.logical().

### 1.1.2 List

Lists are different from atomic vectors because their elements can be of any type, including lists. You construct lists by using list() instead of c():

```{r list, include=FALSE}
x1 <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))

str(x1)

```

Lists are sometimes called recursive vectors, because a list can con- tain other lists. This makes them fundamentally different from atomic vectors.

```{r recursive vector, include=FALSE}

x2 <- list(list(list(list()))) 

str(x2)

#>Listof1
#> $ :List of 1
#>   ..$ :List of 1
#>   .. ..$ : list()

is.recursive(x2)
#> [1] TRUE
```

c() will combine several lists into one. If given a combination of atomic vectors and lists, c() will coerce the vectors to list before combining them. Compare the results of list() and c():

```{r combination of atomic vector and list, include=FALSE}

x3 <- list(list(1, 2), c(3, 4)) 
str(x3)
#> List of 2
#> $ :List of 2
#> ..$ : num 1
#> ..$ : num 2
#> $ : num [1:2] 3 4


y <- c(list(1, 2), c(3, 4)) 
str(y)

```

The typeof() a list is list. You can test for a list with is.list() and coerce to a list with as.list(). You can turn a list into an atomic vector with unlist(). If the elements of a list have different types, unlist() uses the same coercion rules as c().

## 1.2 Atrributes

* All objects can have arbitrary additional attributes, used to store meta data about the object.

* Attributes can be thought of as a named list (with unique names)

* Attributes can be accessed : 
  
  *individually with : attr()

  * all at once (as a list) with : attributes().

```{r attr and attributes, include=FALSE}
y2 <- 1:10

attr(y2, "my_attribute") <- "This is a vector" 

attr(y2, "my_attribute")
#> [1] "This is a vector"

str(attributes(y2))
#>Listof1
#> $ my_attribute: chr "This is a vector"

```

The only attributes not lost are the three most important:

  * Names, a character vector giving each element a name
  
  * Dimensions, used to turn vectors into matrices and arrays
  
  * Class,used to implement the S3 object system

Each of these attributes has a specific accessor function to get and set values. When working with these attributes, use names(x), class(x), and dim(x), not attr(x, "names"), attr(x, "class"), and attr(x, "dim").

### 1.2.1 Names

* You can name a vector in three ways: (function : names () and setnames () )

  1.  When creating it: x<-c(a=1,b=2,c=3).

  2. By modifying an existing vector in place: x <- 1:3; names(x) <- c("a", "b", "c").
  
  3. By creating a modified copy of a vector: x <- setNames(1:3, c("a", "b", "c")).

Not all elements of a vector need to have a name. If some names are missing, names() will return an empty string for those elements. If all names are missing, names() will return NULL.

```{r names, include=FALSE}

y3 <- c(a=1,2,3)
names(y3)

# or this setNames(y3, c('a'))

#> [1] "a" "" ""

z<-c(1,2,3)
names(z)
#> NULL

```

### 1.2.2 Factors

* One important use of attributes is to define factors. 

* A factor is a vector that can contain only predefined values, and is used to store categorical data. 

* Factors are built on top of integer vectors using two attributes :
  
  1. the class(), “factor”, which makes them behave differently from regular integer vectors.
  
  2. the levels(), which defines the set of allowed values.

> common function used on factor : factor (), class (), levels()

```{r factor, include=FALSE}

x1 <- factor(c("a", "b", "b", "a"))
x1
#>[1]abba
#> Levels: a b
class (x1)
#> [1] "factor"
levels(x1)
#> [1] "a" "b"

# You can't use values that are not in the levels
x1[2] <- "c"
#> Warning: invalid factor level, NA generated
x1
#>[1]a <NA>b a
#> Levels: a b

```

Factors are useful when you know the possible values a variable may take, even if you don’t see all values in a given dataset. Using a factor instead of a character vector makes it obvious when some groups contain no observations:

```{r factor case, include=FALSE}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))
table(sex_char) 
#> sex_char
#>m
#>3 table(sex_factor) 
#> sex_factor 
#>m f
#>3 0
```

* Sometimes when a data frame is read directly from a file, a column you’d thought would produce a numeric vector instead produces a factor. 

* This is caused by a non-numeric value in the column, often a missing value encoded in a special way like . or -. 

* To remedy the situation :

  1. coerce the vector from a factor to a character vector
  
  2. and then from a character to a double vector. 
  
* Be sure to check for missing values after this process.
  
* of course, a much better plan is to discover what caused the problem in the first place and fix that ; using the na.strings argument to read.csv() is often a good place to start.

```{r fixing factor while read data from csv, include=FALSE}

z1 <- read.csv(text = "value\n12\n1\n.\n9")

typeof(z1$value)
#> [1] "integer"

as.double(z1$value)
#>[1]3214
# Oops, that's not right: 3 2 1 4 are the levels of a factor, # not the values we read in!

class(z1$value)
#> [1] "factor"

#Wecanfixitnow:
as.double(as.character(z1$value))

#> Warning: NAs introduced by coercion
#>[1]12 1NA 9

# Or change how we read it in:
z1 <- read.csv(text = "value\n12\n1\n.\n9", na.strings=".") 
typeof(z1$value)
#> [1] "integer"

class(z1$value)
#> [1] "integer" z$value
#>[1]12 1NA 9 # Perfect! :)
```

While factors look (and often behave) like character vectors, they are actually integers. Be careful when treating them like strings. Some string methods (like gsub() and grepl()) will coerce factors to strings, while others (like nchar()) will throw an error, and still others (like c()) will use the underlying integer values. For this reason, it’s usually best to explicitly convert factors to character vectors if you need string-like behaviour. In early versions of R, there was a memory advantage to using factors instead of character vectors, but this is no longer the case.

## 1.3 Matrices and Array

* Common function that used to be on matrix and array 

|                         |  matrix                 | array             |
|:------------------------|:-----------------------:|:-----------------:|
|structure                |two dimensions           |Multidimensional   |
|Assignment form          |matrix(),dim()           |array(),dim()      |
|length (ndata)           |length()                 |length()           |
|nrow                     |nrow(),ncol()            |dim()              |
|assigning row & col name |rownames(),colnames()    |dimnames()         |
|binding data             |rbind(),cbind()          |abind()            |
|check matrix or array    |is.matrix()              |is.array()         |
|assign as                |as.matrix()              |as.array()         |
|matrix transpose         |t()                      |t()                |

```{r matrix and array, include=FALSE}

# create matrix and array
matrix_a <-  matrix(data = seq (1,6,1), nrow = 2, ncol = 3)
array_a <-  array(1:6, dim = c(2,3,2)  ) # dim = c (row,col,list no)

# or we can use dim to convert existing object to matrix and array
a <- 1:6
# creating matrix with dim()
dim(a) <- c(2,3)
a

# creating array with dim ()
dim(a) <- c(2,3,1)
a

# view matrix and array structure
dim(matrix_a) # or
dim (array_a)

# view length of whole data (ndata)
length (matrix_a)
length (array_a)

# view length of row data or col (nrow or ncol)

# on matrix and array
nrow(matrix_a)
ncol (array_a)


# assign names of row and col (for indexing row and col) of matrix and array
# for matrix, use rownames() and colnames()
rownames(matrix_a) <- c("a","b")
colnames(matrix_a) <- c("c","d", "e")
matrix_a

# for array, use dimnames()

dimnames(array_a) <- list(c("a","b"), c("c",'d','e'), c('A','B'))
array_a

array_a["A"]

```


```{r binding then check then assign as, include=FALSE}
add_b <- seq (7,12,1)
dim (add_b) <- c(2,3)

rbind(matrix_a, add_b)

# check is it matrix ?
is.matrix(array_a)

# check is it array ?
is.array(matrix_a)

# assign as matrix

as.matrix(add_b)
is.matrix(add_b)


# transpose matrix

t(add_b)

```

> Vectors are not the only 1-dimensional data structure. You can have matrices with a single row or single column, or arrays with a single. see the differences with str () function.


## 1.4 data Frame

data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list.

|                         |  Dataframe              | 
|:------------------------|:-----------------------:|
|structure                |two dimensions           |
|Assignment form          |data.frame()             |
|length (ndata)           |length()                 |
|nrow                     |nrow(),ncol()            |
|assigning row & col name |rownames(),colnames()    |
|binding data             |rbind(),cbind()          |
|check matrix or array    |is.data.frame()          |
|assign as                |as.data.frame()          |
|transpose                |t()                      |




```{r dataframe, include=FALSE}

# create a dataframe
x <- data.frame(x = seq(1,3,1), y = c('a','b','c'))
str(x)

```


### 1.4.1 Testing & Coercion

* Because a data.frame is an S3 class, its type reflects the underlying vector used to build it : the list. 

* To check if an object is a data frame, use class() or test explicitly with is.data.frame()

* to coerce a data frame use as.data.frame ()
  
  * A vector will create a one-column data frame.
  
  * A list will create one column for each element; it’s an error if they’re
not all the same length.
  
  * A matrix will create a data frame with the same number of columns and rows.

```{r test & coercion data.frame, include=FALSE}
# TESTING

typeof(x)
#> "list"

class (x)
#> "data.frame"

is.data.frame(x)
#> TRUE


## COERCE : you can coerce an object to data frame with : as.data.frame ()

y <- c("x" = c(1,2,3),
       "y" = c('a','b','c'))
class(y)

#> "character"

y1 <- as.data.frame(y)
class(y1)
#> "data.frame"

```


### 1.4.2 Combining Data Frames

* we can combine a data frame using cbind() and row cbind() :

```{r cbind, include=FALSE}
cbind(x, z=c(3:1))

rbind(x, z = c(3:2))


```

Key take away of bind row and column of dataframe :

* When combining column-wise, the number of rows must match, but row names are ignored.

* When combining row-wise, both the number and names of columns must match

* Use "plyr::rbind.fill()" to combine data frames that don’t have the same columns.

* avoid bind a factor data type.

> The conversion rules for cbind() are complicated and best avoided by ensuring all inputs are of the same type.

### 1.4.3 Special Columns

* Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list

```{r special column, include=FALSE}

df <- data.frame(x = 1:3)
y <- list(1:2, 1:3, 1:4)

# list add as whole in single cell ()
df$y <- y
df [2]

# it tries to put each item of the list into its own column

# data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
#> arguments imply differing number of rows: 2, 3, 4

# A workaround is to use I(), which causes data.frame() to treat the list as one unit:

# I () stand for : Change the class of an object to indicate that it should be treated ‘as is’.
df1 <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(df1)
df1[2]

```

* Similarly, it’s also possible to have a column of a data frame that’s a matrix or array, as long as the number of rows matches the data frame:

```{r dataframe combined matrix, include=FALSE}
df2 <- data.frame(x = 1:3, 
                  y = I(matrix(data = seq(1,6,1), ncol = 2, nrow = 3)))

str(df2)
df2[2,'y']

```

## 2 SUBSETTING

* The three subsetting operators.

* The six types of subsetting.

* Important differences in behaviour for different objects (e.g., vectors, lists, factors, matrices, and data frames).

* The use of subsetting in conjunction with assignment.

* subsetting operators : [], [[]], $

### 2.1 Subsetting atomic vector

* There are five things that you can use to subset a vector :
  
  1. positive integers : return elements at the specified positions
  
  2. negative integers : omit elements at the specified positions (You can’t mix positive and negative integers in a single subset)
  
  3. Logical: select elements where the corresponding logical value is TRUE
  
  4. NULL ([]) : returns the original vector
  
  5. Zero : Zero returns a zero-length vector. usually used in test data.
  
  6. Character : return elements with matching names

```{r subsetting atomic vector, include=FALSE}
x1 <- seq (1,10,1)

# 1. positive integers : return element in spesific positions
x1 [4:8]
#> [1] 4 5 6 7 8

x1 [c(10,2,6)]
#> [1] 10  2  6

# Duplicated indices yield duplicated values
x1[c(2, 2)]
#> [1] 2 2

# Real numbers are silently truncated to integers
x1[c(2.1, 2.9)]
#> [1] 2 2

# 2. negative integers : omit/remove element in spesific positions

x1 [-1]
#> [1]  2  3  4  5  6  7  8  9 10


x1 [c(-2,-10)]
#> [1]  1  3  4  5  6  7  8  9 

# You can’t mix positive and negative integers in a single subset

# x1[c(-1, 2)]
#> Error in x1[c(-1, 2)] : only 0's may be mixed with negative subscripts

# 3. Logical Vector : return element on TRUE logical positions

x1 [c(T,F,T,F)] # TRUE stand for odd number (angka ganjil)
#> [1] 1 3 5 7 9

# If the logical vector is shorter than the vector being subsetted, it will be recycled to be the same length.

# above equivalent as below :
x1 [c(T,F)]
#> [1] 1 3 5 7 9

#> [1] 1 3 5 7 9
x1 [x1>3]
#> [1]  4  5  6  7  8  9 10

x1 [x1%%2 == 0] # return whole number (angka genap)
#> [1]  2  4  6  8 10

# A missing value in the index always yields a missing value in the output:
x1 [c(T,F,NA,T)]
#> [1]  1 NA  4  5 NA  8  9

# 4. Nothing : return the orignal vector

x1 []
#> 1  2  3  4  5  6  7  8  9 10

# 5. Zero : Zero returns a zero-length vector
x1[0]
#> numeric(0)

x2 <- c('a','b','c')
x2 [0]
#> character(0)

# 6. Character Vector : return elements with matching names

y<- setNames(object = x1, letters[1:10])

y[c('a','j','d')]
#>  a  j  d 
#>  1 10  4 

# Like integer indices, you can repeat indices
y[c('e','e','e')]
#>  e  e  e 
#>  5  5  5  

# When subsetting with [ names are always matched exactly. if any match it will return NA

z <- c('abc' = 1, 'def'=2)
z [c('a','d')]
#> <NA> <NA> 
#>  NA   NA

z[c('abc','def')]
#> abc def 
#> 1   2 



```

### 2.2 Subsetting List

* Subsetting a list works in the same way as subsetting an atomic vector.

### 2.3 Matrices and Arrays

* You can subset higher-dimensional structures in three ways :
  
  1. With multiple vectors.
  
  2. With a single vector.
  
  3. With a matrix.

* subsetting in list in general : supply a 1d index for each dimension, separated by a comma

* Blank subsetting is now useful, because it lets you keep all rows or all columns

* on subsetting arrays, we can do with matrix : 2d matrix for 2d array or matrix, 3d matrix for 3d array and so on. Each row in the matrix specifies the location of one value

```{r subsetting matrix and array, include=FALSE}

# subsetting matrix

a <- matrix (data=1:9, nrow = 3)
colnames(a) <- LETTERS[1:3]

# basic subsetting on list -< [row,col]

a [2,1]
a [c(T,F,T), c(T,T,F)]
a [c(-2), c("C","B")]

b <- outer(1:5, 1:5, FUN = "paste", sep = ",")
b [c(9,15)]

select <- matrix(ncol = 3, byrow = TRUE, data = paste (c(1,3,2),c(1,1,4), 
                                                       sep = ","))

b [select]
#> [1] "1,1" "3,1" "2,4"

```


### 2.4 Data Frames

* Data frames possess the characteristics of both lists and matrices : if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r subsetting data frame, include=FALSE}

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

# basic subsetting data frame -> [row, col]

df[df$x == 2, ]

df[c(1, 3), ]

# Like a list:
df[c("x", "z")] 
#> xz #>11a #>22b #>33c
# Like a matrix
df[, c("x", "z")] 
#> xz #>11a #>22b #>33c

# There's an important difference if you select a single column: matrix subsetting simplifies by default (same datastructure as data frame), list subsetting does not.

# as matrix
str(df["x"])
#> 'data.frame': #> $x:int 123 

# as list
str(df[, "x"])
#> int[1:3]123
```

### 2.5 S3 objects

* S3 objects are made up of atomic vectors, arrays, and lists.
* so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from str().

### 2.6 S4 objects

* There are also two additional subsetting operators that are needed for S4 objects : 
  1. @ (equivalent to $).
  2. slot() (equivalent to [[). 
  
* @ is more restrictive than $ in that it will return an error if the slot does not exist.

## 3 SUBSETTING OPERATORS

* there are 2 subsetting operator :
  
  * $ : is a shorthand operator, where x$y is equivalent to x[["y", exact = FALSE]]
  
  * [[]] : [[ is similar to [, except it can only return a single value and it allows you to pull pieces out of a list. 
  
  * You need [[ when working with lists. This is because when [ is applied to a list it always returns a list: it never gives you the contents of the list. To get the contents, you need [[ . Because it can return only a single value, you must use [[ with either a single positive integer or a string:
  
```{r [[ operator, include=FALSE}
a<-list(a=c(1,2,3) ,b=c(4,5,6))

a [2]
str(a[2])
#> return list of b : [1] 4 5 6
#> List of 1
#> $ b: num [1:3] 4 5 6

a[["b"]]
#> return list of b : [1] 4 5 6
str(a[[2]])
#> num [1:3] 4 5 6

# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1)))) 
b[[c("a", "b", "c", "d")]]
#>[1]1

# Same as
b[["a"]][["b"]][["c"]][["d"]] 
#>[1]1
# Because data frames are lists of columns, you can use [[ to extract a column from data frames

mtcars[[1]]
mtcars[["cyl"]]

```
  
### 3.1 Simplifying vs. preserving subsetting

* Simplifying subsets returns the simplest possible data structure that can represent the output. (output often as vector/list (changed from initial) )

* Preserving subsetting keeps the structure of the output the same as the input (remain initial data structure)
  
|                         |  Simplifying            | Preserving                  |
|:------------------------|:-----------------------:|:---------------------------:|
|Vector                   |x[[1]]                   |x[1]                         |
|list                     |x[[1]]                   |x[1]                         |
|factor                   |x[1:4, drop = T]         |x[1:4]                       |
|Array                    |x[1,] or x[,1]           |x[1,,drop=F] or x[,1,drop=F] |
|Data Frame               |x[,1] or x[[1]]          |x[,1,drop=F] or x[1]         |


> Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below.

```{r simplifying and preserving, include=FALSE}
# 1.  Atomic vector: simplifying will removes names.
x<-c(a=1,b=2) 

# preserving
x[1]
#>a
#>1

class(x[1])
#> [1] "numeric"

# simplifying

x[[1]] 
#>[1]1 -> names be removed

class(x[[1]])
#> "numeric"

# 2. List : preserving return the object inside the list, not a single element list. simplifying will reccursive output and change structure and removes names.

y<-list(a=c(1,2,3),b=c(4,5,6))

# preserving
str(y[1])
#> List of 1
#> $ a: num [1:3] 1 2 3

# simplifying
str(y[[2]])
#>  num [1:3] 4 5 6
class (y[[2]])
#> [1] "numeric"

#. 3 Factor : drops any unused levels.

z <- factor(c("a", "b"))

# preserving
z [1]
#> [1] a
#> Levels: a b

# simpifying
z [1, drop = T]
#> [1] a
#> Levels: a

# 4. Matrix or array: if any of the dimensions has length 1, drops that dimension.

a1 <- matrix(1:4, nrow = 2)

# preserving
a1[1, , drop = FALSE]
#>      [,1] [,2]
#> [1,]    1    3
class(a1[1, , drop = FALSE])
#> [1] "matrix" "array" 

# simpifying
a1 [1,]
#> [1] 1 3
class (a1[1,])
#> [1] "integer"

# 5. Data frame : if output is a single column, returns a vector instead of a data frame.

# preserving

df <- data.frame(a = 1:2, b = 1:2) 
str(df[1])
str(df[, "a", drop = FALSE])
# data structure remains as data frame

# simplifying

str(df[[1]])
str(df[,'a'])
# data structure changed as vector

```

### 3.2 Dollar sign ($)

* $ is a shorthand operator, where x$y is equivalent to x[["y", exact = FALSE]] : simplifying

* One common mistake with $ is to try and use it when you have the name of a column stored in a variable

* There’s one important difference between $ and [[. $ does partial matching

```{r common mistake using $, include=FALSE}

# One common mistake with $ is to try and use it when you have the name of a column stored in a variable

mtcars

var <- "cyl" # cyc is one of column name at mtcars data

mtcars$var
#> NULL
#> # Doesn't work - mtcars$var translated to mtcars[["var"]]

# instead use [[]] or []

mtcars[var]
mtcars[[var]]
```


```{r partial matching $ and [[]], include=FALSE}
x <- list (abc = c(1,2,3,4))

# it return same output
x$a
# equivalent
x$ab
# equivalent
x$abc
#> [1] 1 2 3 4

x[["ab"]]
#> NULL

```


### 3.3 Missing/out of bounds indices

* [ and [[ differ slightly in their behaviour when the index is out of bounds (OOB).

* The following table summarises the results of subsetting atomic vectors and lists with [ and [[ and different types of OOB value.

| Operator   | Index       | Atomic     | List        |
|:----------:|:-----------:|:----------:|:-----------:|
| [          | OOB         | NA         | list(NULL)  |
| [          | NA_real_    | NA         | list(NULL)  |
| [          | NULL        | x[0]       | list(NULL)  |
| [[         | OOB         | Error      | Error       |
| [[         | NA_real_    | Error      | NULL        |
| [[         | NULL        | Error      | Error       |

```{r missing/out of bounds, include=FALSE}
x<-1:4
x1 <- list(1:4)
x[5]
#> [1] NA
x1[2]

x1[[NA_real_]]
```

### 3.4. Subsetting & Assignment

* All subsetting operators can be combined with assignment to modify selected values of the input vector.

```{r subsetting & assignment, include=FALSE}
x <- c(1:5)

x[c(3,5)] <- c(10,20)
#> [1]  1  2 10  4 20

# The length of the LHS needs to match the RHS
x [c(-1,-2)] < 4:1
# length doesnt match, so it return an error

x [-1] <- 4:1
#> [1] 1 4 3 2 1
#> Note that there's no checking for duplicate indices

# You can't combine integer indices with NA

x[c(1, NA)] <- c(1, 2)

#> Error in x[c(1, NA)] <- c(1, 2) : 
#> NAs are not allowed in subscripted assignments

# But you can combine logical indices with NA
# (where they're treated as false).
x[c(T, F, NA)] <- 1
x
#> [1] 1 4 3 1 1

# This is mostly useful when conditionally modifying vectors
df <- data.frame(x = c(1,NA,3,4,5),
                 y = c(6,7,8,NA,10))

df$x [df$y <= 7]
#> [1]  6  7 NA
#> NA will be kept, no matter T or F and it will return NA too.
#> logical operator will return T or F,then subsetting will logically behave

```

### 3.5 Applications

#### 3.5.1 Lookup Tables (Character Subsetting)

Character matching provides a powerful way to make lookup tables. 

```{r lookup tables, include=FALSE}

# for lookup, keep in my behaviour of subsetting : positive integer, negative integer, character, NULL, ZERO and logical. also, behaviour of data type :vector, list, array etc

x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)

lookup[x] # artinya ambil data lookup sesuai data susunan data x

# remove names
unname(lookup[x])

x1 <- c(1,2,3,4)
y1 <- c(T,F,T,F)

x1 [y1] # ambil data x1 sesuai dengan var y1


x2 <- -2
x1 [x2]


# lookup in data frame
df1 = data.frame(gender = c('m','m','f'),
                 score = c(10,9,11))

df1$gender <- lookup[df1[,1]]

# or
df2 = data.frame(gender = c('m','m','f'),
                 score = c(10,9,11))

lookup[df2$gender]

```

#### 3.5.2 Matching and Merging by Hand (Integer subsetting)

* You may have a more complicated lookup table which has multiple columns of information


```{r matching and merging on multiple column, include=FALSE}

x <- c(1, 2, 2, 3, 1)


df <- data.frame(grade = 3:1,
                 desc = c("Excellent","Good", "Poor"),
                 fail = c(F, F, T))
# 1. with match
# define id lookup
id <- match (x = x,table =  df[,"grade"])
df [id,]

#2. with rownames()
rownames(df) # from this we know, that row names is character, so convert x as char to return df data as x values

df [as.character (x), ]

# 3. basic subsetting
# or you can do manually with basic lookup subsetting
df [df$grade[x],] # ambil data df sesuai dengan posisi df$grade berdasarkan x


```

> If you have multiple columns to match on, you’ll need to first collapse them to a single column (with interaction(), paste(), or plyr::id()). You can also use merge() or plyr::join(), which do the same thing for you — read the source code to see how.

#### 3.5.3 Random Samples / Bootstrap (Integer Subsetting)

* You can use integer indices to perform random sampling or bootstrap- ping of a vector or data frame.

* sample() generates a vector of indices, then subsetting to access the values

```{r random samples (bootstraping), include=FALSE}
df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])

# basic bootstraping
df [sample(nrow(df)),]

# boostraping 3 rows
df [sample(nrow(df), 3), ]

# boostraping with replicate/duplicate value indices
df [sample(nrow(df), replace = TRUE), ]


```

#### 3.5.4 Ordering (integer subsetting)

* order() takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered (mengurutkan posisinya)

* For two or more dimensions, order() and integer subsetting makes it easy to order either the rows or columns of an object

```{r ordering subsetting, include=FALSE}

x <- c ("c","b",'a')

order (x)
#> [1] 3 2 1 -> urutan c b a dalam abjad.

x [order(x)]
#> [1] "a" "b" "c"

random_sample <- sample (10)
random_sample[order(random_sample)]

# order two dimension or more with order subsetting

df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])


# ordering row 
df [order(df[['y']]), ]

df [order(df$z),]

# ordering col
df [, order(names(df))]

```

> More concise, but less flexible, functions are available for sorting vectors, sort(), and data frames, plyr::arrange().

#### 3.5.5 Expanding aggregated counts (integer subsetting)

* Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. 

* rep() and integer subsetting make it easy to uncollapse the data by subsetting with a repeated row index.

```{r Expanding aggregated counts, include=FALSE}
df2 <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

rep(1:nrow(df2), df2$n)
#> [1] 1 1 1 2 2 2 2 2 3

df2[rep(1:nrow(df2), df2$n), ]
```

#### 3.5.6 Removing columns from data frames (character subsetting)

* There are two ways to remove columns from a data frame : 
  1. You can set individual columns to NULL
  
  2. you can subset to return only the columns you want
  
```{r Removing columns from data frames, include=FALSE}
df3 <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

# 1. Removing columns from data frames
df3$y <- NULL
df3

# 2.  subset to return only the columns you want
df3 [, c("x","n")]

# or
# combine with setdiff () function
df3 [, setdiff(names(df3), "x")] # remove column x

```


#### 3.5.7 Selecting rows based on a condition (logical subsetting)

* Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame



```{r Selecting rows and cols based on a condition, include=FALSE}
# selecting rows
mtcars [mtcars[['gear']],]
mtcars [mtcars[['gear']] == 5 & mtcars$cyl == 4,]

# selecting col
mtcars [ , names(mtcars) == "gear" | names(mtcars) == "cyl"  ]
```
> Remember to use the vector boolean operators & and |, not the shortcircuiting scalar operators && and || which are more useful inside if statements

1. & Operator adalah operator logis dan juga bitwise, karena beroperasi pada boolean maupun data biner, sedangkan operator && hanyalah operator logis karena hanya beroperasi pada tipe data boolean.

2. Operator & mengevaluasi kedua sisi ekspresi untuk mendapatkan hasil akhir sedangkan, operator && hanya mengevaluasi sisi kiri ekspresi & jika ternyata salah, ia bahkan tidak mengevaluasi sisi kanan ekspresi. 

```{r logical operator, include=FALSE}
a <- c(T,F,T,T)
b<- c(T,T,F,F)

# & operator : dia akan mengevaluasi sisi kiri dan kanan, return sesuai panjang kedua input.

a & b 
#> [1]  TRUE FALSE FALSE FALSE

# && operator : Ketika kita gunakan operator && pada a && b maka yang akan dievaluasi adalah elemen pertama dari a dan b


```


other logical operator :

* !(X & Y) is the same as !X | !Y

* !(X | Y) is the same as !X & !Y

* For example, !(X & !(Y | Z)) simplifies to !X | !!(Y|Z), and then to !X | Y | Z.

* subset() is a specialised shorthand function for subsetting data frames, and saves some typing because you don’t need to repeat the name of the data frame.

```{r subset functions, include=FALSE}
mtcars


# subset functions : subset (x, subset/logical conditions, select)
subset (x = mtcars, subset = cyl > 5, select = c(mpg,qsec))

# subset multiple columns
subset (mtcars, mpg <= 21 & am != 1 )

# or

subset (mtcars, !(mpg >= 21 | am == 1) ) # !X & !Y

```


#### 3.5.8 Boolean algebra vs. sets (logical & integer subsetting)

* It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). 

* Using set operations is more effective when :

  1. You want to find the first (or last) TRUE.
  
  2. You have very few TRUEs and very many FALSEs; a set representation may be faster and require less storage.

* which() allows you to convert a boolean representation to an integer representation.

```{r which function, include=FALSE}
x <- sample(100, 10)

which (x < 80)

x [which(x<80)]

# unwhich functions (manually defined)
 
unwhich <- function(x, n) {
   out <- rep_len(FALSE, n)
   out[x] <- TRUE
   out
}
unwhich(which(x < 80), 10)

```

Let’s create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.

```{r create 2 logical vector and explore relationship between them , include=FALSE}
x1<-1:10%%2==0 # logical vector

x2 <- which(x1) # integer vector

y1<-1:10%%5==0 # logical vector
y2 <- which(y1) # integer vector


# explore relationship between vector
# 1. X & Y <-> intersect(x, y) for integer or which (x & y) for logical

x1 & y1
which (x1 & y1)

intersect (x2,y2)

# 2, #X|Y<->union(x,y)
union (x2, y2) # subset only return TRUE values

# 3. X & !Y <-> setdiff(x, y)
setdiff (x2,y2)

# 4. xor(X, Y) <-> setdiff(union(x, y), intersect(x, y)) #kebalikan x dan y

xor (x1, y1)

setdiff(union(x2, y2), intersect(x2, y2))


```


* key take a note :

  1. which () : switches from logical to integer subsetting
  
  2.  x[-which(y)] is not equivalent to x[!y] : if y is all FALSE, which(y) will be integer(0) and -integer(0) is still integer(0)
  
  3. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last TRUE value.
  
  
## 4 VOCABULARY


### 4.1 Basic

#### 4.1.1 The first functions to learn

* ? 

* str

#### 4.1.2 Important operators and assignment

* %in% : match returns a vector of the positions of (first) matches of its first argument in its second.

* match : match returns a vector of the positions of (first) matches of its first argument in its second. (same as %in%)

* =

* <-

* <<- : make a global scope var

* $, [, [[, head, tail

* subset : selecting / subsetting based on condition. subset (data, subset = condition)

* with : Evaluate an R expression in an environment constructed from data, possibly modifying (a copy of) the original data.

* assign : Assign a value to a name in an environment.

* get : search by name for an object (get) or zero or more objects (mget).

```{r operator and assignment vocab, include=FALSE}

# 1. %in%

x <- c(1,2,3,4,5,6)
y <- c(2,3,4)

5 %in% x
#> [1] TRUE

10 %in% x
#> [1] FALSE

x %in% y

# 2. subset : selecting / subsetting based on conditional 

subset (x, subset = y > 3) # subset y > 3 will return [3]. then [3] will used as index to get values from x

# 3. with 

# syntax : with(data-frame, R expression)

data_A <- data.frame(num =  c(100,100,100,100,100),
                     cost =c(1200,1300,1400,1500,1600))

with(data_A, num*cost)
with(data_A, cost/num)

# with juga bisa digunakan sebagai subsetting dengan conditional

with(data_A, num >= 100 & cost >= 1400)
#> [1] FALSE FALSE  TRUE  TRUE  TRUE 

# 4. Assign : Assign a value to a name in an environment.
# syntax : assign ("var name", value to be assigned)

x1 <- c(11,12,13,14)

assign ("x1 [3]",'aa')

# 5. get : search by name for an object (get) or zero or more objects (mget).

get ("x1 [3]")
#> [1] "aa"

```


#### 4.1.3 Comparison

* all.equal : Test if Two Objects are (Nearly) Equal

* identical : Test Objects for Exact Equality

* !=, ==, >, >=, <, <=

* is.na : The generic function is.na indicates which elements are missing.

* complete.cases : Return a logical vector indicating which cases are complete, i.e., have no missing values.

* is.finite & is.infinite : is.finite and is.infinite return a vector of the same length as x, indicating which elements are finite (not infinite and not missing) or infinite.

```{r comparison, include=FALSE}

# 1. all.equal () : Test if Two Objects are (Nearly) Equal

all.equal (11,11)
#> [1] TRUE

all.equal (11,11.5) 
#> "Mean relative difference: 0.04545455"

all.equal ("aaaa","abab")
#> [1] "1 string mismatch"


# 2. identical () : Test Objects for Exact Equality
identical (1,"1")
# [1] FALSE

identical (11,11)
# [1] TRUE

identical ("aaaa","aaaa")
#> [1] TRUE

identical ("aacc","cacaaa")
#> [1] FALSE


# 3. complete.cases() :  Return a logical vector indicating which cases are complete (is it TRUE or FALSE)

x <- airquality[, -1] # x is a regression design matrix
y <- airquality[,  1] # y is the corresponding response

x2 <- c(1,NA,3,NA)
y2 <- c(1,2,NA,NA)

complete.cases (x2)
#> [1]  TRUE FALSE  TRUE FALSE

complete.cases(x1,y1)

complete.cases(x2,y2)
#> [1]  TRUE FALSE FALSE FALSE


# 4. is.finite () & is.infinite

Inf # infinite

is.finite(Inf)
#> [1] FALSE

is.finite(1)
#> [1] TRUE

is.infinite(x2)
#> [1] FALSE FALSE FALSE FALSE

```

#### 4.1.4 Basic Math

* *, +, -, /, ^, %%, %/%

* abs, sign

* acos, asin, atan, atan2

* sin, cos, tan

* ceiling, floor, round, trunc, signif

* exp, log, log10, log2, sqrt


* max, min, prod, sum

* cummax, cummin, cumprod, cumsum, diff

* pmax, pmin

* range

* mean, median, cor, sd, var

* rle

     
#### 4.1.5 Functions to do with functions

* function

* missing : missing can be used to test whether a value was specified as an argument to a function.

* on.exit :  function is used to record a given function to be called when the present or current function exits.

* return

* invisible : Return a (temporarily) invisible copy of an object.



```{r functions to do functions, include=FALSE}
# functions

coba_function <- function(n,b) { n +b }
                           
coba_function(10,11)                          


# Missing Functions :  missing can be used to test whether a value was specified as an argument to a function.

coba_function2 <- function (x) { return (missing (x))}

coba_function2 ()
#> [1] TRUE

coba_function2(2)
#> [1] FALSE

coba_function3 <- function (x,y) { if (missing (x) == T) { 
  print ('argument x is missing')}
  else {print("nothing argument is missing")}
}


coba_function3(,y = 1)
#> [1] "argument x is missing"

# 3. on.exit :  function is used to record a given function to be called when the present or current function exits.

# syntax : on.exit(expr = NULL, add = FALSE, after = TRUE)


# =============== on.exit applications =======================

# creating functions
function_2 <- function() {
  # calling the on.exit() function 
  on.exit(print('function_two exited'));

  print('I am in function_two');
}

# creating another function 
function_1 <- function() {
  # calling the on.exit() function 
  on.exit(print('function_one exited'));

  print('I am in function_one and am going to call function_two');
  
  # calling functio_two
  function_2();
}

# calling the function_1
function_1()

# =============================================================


# 4. Invisible : Return a (temporarily) invisible copy of an object.

invisible(coba_function2())
#> 
```

#### 4.1.6 Logical & sets

* &,|,!,xor

* all : Given a set of logical vectors, are all of the values true?

* any : Given a set of logical vectors, are all of the values true?

* intersect : finds all rows in both x and y.

* union : finds all rows in either x or y, excluding duplicates.

* setdiff :setdiff(x, y) finds all rows in x that aren't in y.

* setequal :  returns TRUE if x and y contain the same rows (ignoring order).

* which : Give the TRUE indices of a logical object, allowing for array indices.


#### 4.1.7 Vectors and matrices

* c : create vector

* matrix : create matrix

#### 4.1.8 automatic coercion rules character > numeric > logical

* length, dim, ncol, nrow

* cbind, rbind : binding col or row

* names, colnames, rownames : get a index names or col names or row names

* t : transpose matrix

* diag : Extract or replace the diagonal of a matrix, or construct a diagonal matrix.

* sweep : Return an array obtained from an input array by sweeping out a summary statistic.

* as.matrix, data.matrix : convert data to matrix

#### 4.1.8 Making Vectors

* c

* rep, rep_len : rep replicates the values in x

* seq, seq_len, seq_along : Generate regular sequences

* rev : rev provides a reversed version of its argument. It is generic function with a default method for vectors and one for dendrograms.

* sample :sample takes a sample of the specified size from the elements of x using either with or without replacement

* choose, factorial, combn (is/as).(character/numeric/logical/...)

#### 4.1.9 Lists & data.frames
* list, unlist

* data.frame, as.data.frame

* split : split divides the data in the vector x into the groups defined by f

* expand.grid : Create a data frame from all combinations of the supplied vectors or factors

#### 4.1.10 Control flow

if, &&, || (short circuiting)

for, while

next, break

switch

ifelse

#### 4.1,11 Apply & friends

* lapply, sapply, vapply

* apply

* tapply

* replicate

### 4.2 Common data structures

#### 4.2.1 Date time

ISOdate, ISOdatetime, strftime, strptime, date
difftime
julian, months, quarters, weekdays
library(lubridate)

#### 4.2.2 Character manipulation


* grep, agrep : search for matches to argument pattern within each element of a character vector

* gsub, sub :  replacement of the first and all matches respectively

* strsplit : Split the elements of a character vector x into substrings according to the matches to substring split within them

* chartr : Translate characters in character vectors, in particular from upper to lower case or vice versa (merubah beberapa karakter/element ke beberapa element/character lain)

* nchar

* tolower, toupper

* substr : Extract or replace substrings in a character vector. (seperti fungsi mid di excel)

* paste : Concatenate vectors after converting to character.

* packages also have same functions : stringr

```{r character manipulation, include=FALSE}

x <- c('adi','setiawan','learn','rprogramming')

# 1. grep, agrep : search for matches to argument pattern within each element of a character vector

grep('[mm]', x)
#> [1] 4

grep(pattern = 'adi', x)
#> [1] 1


# 2. gsub :  replacement of the first and all matches respectively

gsub(pattern = 'adi',replacement = 'ADI', x = x)


# 3. chartr : Translate characters in character vectors, in particular from upper to lower case or vice versa (merubah beberapa karakter/element ke beberapa element/character lain)

chartr("awi",new = 'AWI', x)
#> [1] "AdI"          "setIAWAn"     "leArn"        "rprogrAmmIng"


# 4. substr : Extract or replace substrings in a character vector.
substr(x, start = 1, stop = 3)
#> "adi" "set" "lea" "rpr"


# 5. paste : Concatenate vectors after converting to character.

paste(x[1], x[2], sep = " ")
#> [1] "adi setiawan"

```

#### 4.2.3 Factors

* factor, levels, nlevels, gl

* reorder, relevel

* cut, findInterval

* interaction : interaction computes a factor which represents the interaction of the given factors. The result of interaction is always unordered.

* options(stringsAsFactors = FALSE)


```{r factor vocabulary, include =FALSE}

# 1. Factor

# vector 
x <- c('m','m','f','m','f')

factor(x = x,levels = c('m','f'))


```


#### 4.2.4 Array manipulation

* array

* dim

* dimnames

* aperm : Transpose an array by permuting its dimensions and optionally resizing it.

* library(abind)      

### 4.3 Statistics

#### 4.3.1 Ordering and tabulating
* duplicated, unique

* merge

* order, rank, quantile

* sort

#### 4.3.2 Linear models

* fitted, predict, resid, rstandard

* lm, glm

* hat, influence.measures

* logLik, df, deviance

* formula, ~, I

* anova, coef, confint, vcov

* contrasts

* table, ftable

### 4.4 I/O Vocabulary
#### 4.4.1  Output

* print, cat

* message, warning

* dput

* format

* sink, capture.output

#### 4.4.2 Reading and writing data

* data
* count.fields
* read.csv, write.csv
* read.delim, write.delim
* read.fwf
* readLines, writeLines
* readRDS, saveRDS
* load, save
* library(foreign)

#### 4.4.3 Files and directories
* dir
* basename, dirname, tools::file_ext
* file.path
* path.expand, normalizePath
* file.choose
* file.copy, file.create, file.remove, file.rename, dir.create file.exists, file.info
* tempdir, tempfile
* download.file, library(downloader)

## 5. Functions

* The most important thing to understand about R is that functions are objects in their own right

### 5.1 Function Components

3 components of functions : 

* the body(), the code inside the function. (in {})

* the formals(), the list of arguments which controls how you can call the function.

* theenvironment(),the “map” of the location of the function’s variables.

* When you print a function in R, it shows you these three important components. **If the environment isn’t displayed**, it means that the function was created in the global environment.

```{r function components, include=FALSE}

f<- function (x) {x^2}

#how to check formals functions
formals(f)
#> $x

#  check environment functions
environment(f)
#> <environment: R_GlobalEnv>

# detail of f function 
# body function : x^2
# formals : $x
# environment : R_GlobalEnv>
```

* functions can also possess any number of additional attributes()

* One attribute used by base R is “srcref”, short for source reference

* this contains code comments and other formatting. You can also add attributes to a function. For example, you can set the class() and add a custom print() method

#### 5.1.1 Primitive Functions

* There is one exception to the rule that functions have three components. Primitive functions, like sum().

* Therefore their formals(), body(), and environment() are all NULL

* Primitive functions are only found in the base package,


### 5.2 Lexical scoping

* Scoping is the set of rules that govern how R looks up the value of a symbol.

* Understanding scoping allows you to:

  1. build tools by composing functions
  
  2. overrule the usual evaluation rules and do non-standard evaluation
  
* R has two types of scoping : 
  
  1. lexical scoping, implemented automatically at the language level
  
  2. dynamic scoping, used in select functions to save typing during interactive analysis

* Lexical scoping looks up symbol values based on how functions were nested when they were created

* With lexical scoping, you don’t need to know how the function is called to figure out where the value of a variable will be looked up. You just need to look at the function’s definition.

* There are four basic principles behind R’s implementation of lexical scoping:

  1. name masking
  
  2. functions vs. variables
  
  3. a fresh start
  
  4. dynamic lookup
  
#### 5.2.1 Name Masking

```{r name masking, include=FALSE}

d <- function() {
  x<-1
  y<-2
  c(x, y) }

d() 

rm(d)

# If a name isn’t defined inside a function, R will look one level up.

x<-2
g <- function() {
  y<-1
  c(x, y) }

g() 

rm(x, g)
```

* The same rules apply if a function is defined inside another function: look inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages. Run the following code in your head, then confirm the output by running the R code.

```{r name masking on nested function, include=FALSE}

x<-1
h <- function() {
  y<-2
  i <- function() { 
    z<-3
    c(x, y, z) }
  i() }

h() 

rm(x, h)


j <- function(x) {
  y<-2
  function() {
    c(x, y)
    } }
k <- j(1)
k()
rm(j, k)
```

#### 5.2.2 Functions vs. variables

* The same principles apply regardless of the type of associated value — finding functions works exactly the same way as finding variables

```{r functions vs variable, include=FALSE}

l <- function(x) x + 1

m <- function() {
  l <- function(x) x * 2
  l(10)
}

m()
#> [1] 20 -> it show r scoping on local first


rm(l,m)


```

* If you are using a name in a context where it’s obvious that you want a function. R will ignore objects that are not functions while it is searching. In the following example n takes on a different value depending on whether R is looking for a function or a variable

```{r}
n <- function(x) x / 2
o <- function() {
  n<-10
  n(n) }

o() 
#>[1]5 

rm(n, o)
```

> However, using the same name for functions and other objects will make for confusing code, and is generally best avoided.

#### 5.2.3 Fresh Start

* What happens to the values in between invocations of a function? What will happen the first time you run this function? What will happen the second time? (If you haven’t seen exists() before: it returns TRUE if there’s a variable of that name, otherwise it returns FALSE.)

```{r}

j <- function() {
  if (!exists("a")) {
    a<-1 }
  else{
    a<-a+1 }
  print(a) }

j() 
rm(j)
```

> You might be surprised that it returns the same value, 1, every time. This is because every time a function is called, a new environment is created to host execution. A function has no way to tell what happened the last time it was run; each invocation is completely independent.

#### 5.2.4 Dynamic lookup

* Lexical scoping determines where to look for values, not when to look for
them

* R looks for values when the function is run, not when it’s created.
This means that the output of a function can be different depending on
objects outside its environment


```{r dynamic lookup, include=FALSE}

y <- function () {x}

x <- 2
y()
#> [1] 2

x <- 10
y()
#> [1] 10
```

* You generally want to avoid this behaviour because it means the function
is no longer self-contained

* due to, it;s depending on what variables are defined in the global environment.

* One way to detect this problem is the findGlobals() function from
codetools : to lists all the external dependencies of a function

* Another way to try and solve the problem would be to manually change
the environment of the function to the emptyenv() : an environment which
contains absolutely nothing

```{r dynamic lookup findGlobals, include=FALSE}

# 1. findGlobals ()
z <- function () {x+1}

codetools::findGlobals(z)
#> [1] "{" "+" "x"

# 2. emptyenv() : Get, set, test for and create environments.

environment(z) <- emptyenv()
z ()
#> Error in { : could not find function "{"

# This doesn’t work because R relies on lexical scoping to find everything, even the {} operator.

```


### 5.3 Every operation is a function call 

“ To understand computations in R, two slogans are helpful:

  * Everything that exists is an object.
  
  * Everything that happens is a function call.”

—- John Chambers


> Note that `, the backtick, lets you refer to functions or variables that have otherwise reserved or illegal names

```{r everything is a function call, include=FALSE}

x <- 10
y <- 5
x+y

#> [1] 15

'+'(x,y)
#> [1] 15

for (i in seq(1,3,1)) 
  print (i)
#> [1] 1
#> [1] 2
#> [1] 3

'for'(i,seq(1,3,1), print (i))
#> [1] 1
#> [1] 2
#> [1] 3

i <- 4
if (i == 3)
  print ('yes') else 
  print ('nope')

'if' (i==3, print ('yes'),'nope')
#> [1] "nope"

```

* It’s more often useful to treat special functions as ordinary functions. For example, we could use sapply() to add 3 to every element of a list by first defining a function add(), like this

```{r sapply and lapply, include=FALSE}
add <- function (x,y) {x+y}
sapply(1:10, add, 3)
#>  [1]  4  5  6  7  8  9 10 11 12 13

# difference between ' and " :
  # 1. ' read as object in r
  # 2. while " read as character
# applications can be found in sapply and lapply, while lapply and sapply can be given name of the function (use "")

sapply(1:5, `+`, 3) 
#>[1] 4 5 6 7 8 
sapply(1:5, "+", 3) 
#>[1] 4 5 6 7 8

# A more useful application is to combine lapply() or sapply() with sub- setting:
x <- list(1:3, 4:9, 10:12) 
sapply(x, "[", 2)
#>[1] 2 5 11

# equivalent to
sapply(x, function(x) x[2]) 
#>[1] 2 511

```


### 5.4 Function arguments

* It’s useful to distinguish between the formal arguments and the actual arguments of a function. 

* The formal arguments are a property of the function, whereas the actual or calling arguments can vary each time you call the function


#### 5.4.1 Calling Functions

* When calling a function you can specify arguments by position, by complete name, or by partial name. Arguments are matched first by exact name (perfect matching), then by prefix matching, and finally by position.

```{r calling fucntions, include = FALSE}

f <- function(abcdef, bcde1, bcde2) {
  list(a = abcdef, b1 = bcde1, b2 = bcde2)
}

str(f(1,2,3))
#>Listof3
#> $a:num1
#> $b1:num2
#> $b2:num3

str(f(2, 3, abcdef = 1)) 
#>Listof3
#> $a:num1 
#> $b1:num2
#> $b2:num3

# Can abbreviate long argument names:
str(f(2, 3, a = 1)) 
#>Listof3
#> $a:num1
#> $b1:num2
#> $b2:num3
# But this doesn't work because abbreviation is ambiguous
str(f(1, 3, b = 1))
#> Error: argument 3 matches multiple formal arguments

```

> it's will be nice if you use perfect matching, to avoid ambigous arguments.

#### 5.4.2 Calling a function given a list of arguments

```{r calling function given list of arguments, include = FALSE}

# Suppose you had a list of function arguments:
args <- list(1:10, na.rm = TRUE)
# How could you then send that list to mean()? You need do.call():
do.call(mean, list(1:10, na.rm = TRUE))
#> [1] 5.5

# Equivalent to
mean(1:10, na.rm = TRUE)
#> [1] 5.5

```


#### 5.4.3 Default and missing arguments

```{r}
f<-function(a=1, b=2) {c(a, b)}
f()
#>[1] 1 2
```

#### 5.4.4 Lazy evaluation

* By default, R function arguments are lazy — they’re only evaluated if they’re actually used

```{r lazy evaluations of function, include=FALSE}
f <- function(x) {
10
}

f (stop('stop this will be error'))
#> [1] 10

# If you want to ensure that an argument is evaluated you can use force():
f <- function(x) {
  force(x)
10
}
f(stop("This is an error!"))
#> Error: This is an error!
f(1)
#> [1] 10 force : Forces the evaluation of a function argument is it TRUE or FALSE.

# This is important when creating closures with lapply() or a loop

add <- function(x) {
  function(y) x + y
}

adders <- lapply(1:10, add)
adders[[1]](10)
#> [1] 11
adders[[10]](10)
#> [1] 20

# for evaluated and show list of object of a functions, you can use ls () :

add(ls())
```

* More technically, an unevaluated argument is called a promise, or (less commonly) a thunk. A promise is made up of two parts:

  * The expression which gives rise to the delayed computation. (It can be accessed with substitute())
  
  * The environment where the expression was created and where it should be evaluated.


#### 5.4.5 ... called by special arguments

* This argument will match any arguments not otherwise matched, and can be easily passed on to other functions

* This is useful if you want to collect arguments to call another function, but you don’t want to prespecify their possible names.

* often used in conjunction with S3 generic functions to allow individual methods to be more flexible

* To capture ... in a form that is easier to work with, you can use list(...)

* Using ... comes at a price — any misspelled arguments will not raise an error, and any arguments after ... must be fully named. This makes it easy for typos to go unnoticed

```{r ... argument, include=FALSE}

# for detail of you can read documentation of any functions 

plot(1:5, col = "red") # >> col is ex of ... argument, cause col isnt spesific argument of plot functions

plot(1:5, cex = 5, pch = 20) # >> cex and pch also ... arguments

# from that ex, we know it possible call others function arguments.

# To capture ... in a form that is easier to work with, you can use list(...)
f <- function(...) {
  names(list(...))
} 
f(a=1,b=2) 
#> [1] "a" "b"

# price using ... is any misspelled argument may be unnoticed - easy for any typos 
sum(1, 2, NA, na.mr = TRUE)
#> [1] NA
```

> It’s often better to be explicit rather than implicit, so you might instead ask users to supply a list of additional arguments. That’s certainly easier if you’re trying to use ... with multiple additional functions.

### 5.5 Special Calls

* R supports two additional syntaxes for calling special types of functions: infix and replacement functions.

#### 5.5.1 infix functions.

* Most functions in R are “prefix” operators: the name of the function comes before the arguments. 

* You can also create infix functions where the function name comes in between its arguments, like + or -. 

* All user created infix functions must start and end with % and R comes with the following infix functions predefined: %%, %*%, %/%, %in%, %o%, %x%. 

* The complete list of built-in infix operators that don’t need % is: ::, :::, $, @, ˆ, *, /, +, -, >, >=, <, <=, ==, !=, !, &, &&, |, ||, ~, <-, <<- 

```{r infix functions, include=FALSE}

'%+%' <- function (a,b) {paste(a, b, sep = ' ')}

'halo' %+% 'this infix calling function'
#> [1] "halo this infix calling function"



```


#### 5.5.2 Replacement functions.

* Replacement functions act like they modify their arguments in place,  and have the special name xxx<-

* They typically have two arguments (x and value)

* although they can have more, and they must return the modified object

* the following function allows you to modify the second element of a vector

```{r replacement functions, include=FALSE}
`second<-` <- function(x, value) {
  x[2] <- value
  x
}
x <- 1:10
second(x) <- 5L
x
#> [1]  1  5  3  4  5  6  7  8  9 10
```

## 6 Return Values

* The last expression evaluated in a function becomes the return value, the result of invoking the function

* Functions can return only a single object. But this is not a limitation because you can return a list containing any number of objects.

* The functions that are the easiest to understand and reason about are pure functions: functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no side effects

```{r return value, include=FALSE}
f <- function(x) {
  if (x < 10) {
    0
  } else
    10
} 
f(5)
#> [1] 0
f (11)
#> [1] 10

f <- function (x,y) {
  if (!x) return (y)
  
  # complicated processing here
}

f(FALSE,2)


# pure functions's behave

f <- function(x) { 
  x$a <- 2 
  x 
}

x <- list(a=c(1,2,3,4))

f(x)
#> $a
#> [1] 2

x$a
#> [1] 1 2 3 4

# There are two important exceptions to the copy-on-modify rule: envi- ronments and reference classes. These can be modified in place, so extra care is needed when working with them.

```

* Most base R functions are pure, with a few notable exceptions:

  1. library() which loads a package, and hence modifies the search path.

  2. setwd(), Sys.setenv(), Sys.setlocale() which change the working directory, environment variables, and the locale, respectively.

  3. plot() and friends which produce graphical output.

  4. write(), write.csv(), saveRDS(), etc. which save output to disk.

  5. options() and par() which modify global settings.
  
  6. S4 related functions which modify global tables of classes and methods.

  7. Random number generators which produce different numbers each time you run them.

* how to deal with invisible value ? You can force an invisible value to be displayed by wrapping it in parentheses:

```{r force an invisible value, include=FALSE}

f1 <- function () 1
f2 <- function () invisible (1)

f1 () == 1
#> [1] TRUE

f2()
#> 

# to show value of f2, you can force invisible function by wrapping it with in "()" paranthesis :

(f2())
#> [1] 1

# The most common function that returns invisibly is <-:
a <- 2
(a <- 2)
#> [1] 2

```

### 6.1 On Exit

* functions can set up other triggers to occur when the function is finished using on.exit().

* This is often used as a way to guarantee that changes to the global state are restored when the function exits.

* The code in on.exit() is run regardless of how the function exits, whether with an explicit (early) return, an error, or simply reaching the end of the function body.

```{r on exit, include=FALSE}
in_dir <- function (dir,code) {
  old <- setwd(dir)
  on.exit(setwd(old))
  
  force (code)
}

old <- getwd()
in_dir("~", old)
#> [1] "D:/DATA-ADI/git_github/github_rprogramming/github_rprogramming"


```
* The basic pattern is simple:

  * We first set the directory to a new location, capturing the current location from the output of setwd().
  
  * We then use on.exit() to ensure that the working directory is returned
to the previous value regardless of how the function exits.

  * Finally, we explicitly force evaluation of the code. (We don’t actually
need force() here, but it makes it clear to readers what we’re doing.)

> Caution: If you’re using multiple on.exit() calls within a function, make sure to set add = TRUE. Unfortunately, the default in on.exit() is add = FALSE, so that every time you run it, it overwrites existing exit expressions. Because of the way on.exit() is implemented, it’s not possible to create a variant with add = TRUE, so you must be careful when using it.

## 7. OO (object oriented) field guide

* This chapter is a field guide for recognising and working with R’s objects in the wild

* R has three object oriented systems plus the base types : S3, S4, refference classes and base types

* The goal of this guide is not to make you an expert in all four systems, but to help you identify which system you’re working with and to help you use it effectively

* Central to any object-oriented system are the concepts of class and method.

* **A class defines the behaviour of objects by describing their attributes and their relationship to other classes.**

* **The class is also used when selecting methods, functions that behave differently depending on the class of their input.**

* Classes are usually organised in a hierarchy: if a method does not exist for a child, then the parent’s method is used instead; the child inherits behaviour from the parent.

* R’s three OO systems differ in how classes and methods are defined:

  1. S3
  
  * S3 implements a style of OO programming called generic function OO.
  
  * This is different from most programming languages, like Java, C++, and C#, which implement message-passing OO.
  
  * With message passing, messages (methods) are sent to objects and the object determines which function to call. Typically, this object has a special appearance in the method call, usually appearing before the name of the method/message: e.g., canvas.drawRect("blue").
  
  * While computations are still carried out via methods, a special type of function called a generic function decides which method to call, e.g., drawRect(canvas, "blue"). S3 is a very casual system. It has no formal definition of classes.
  
  2. S4
  
  * S4 works similarly to S3, but is more formal

  * There are two major differences to S3 : 
  
    1. S4 has formal class definitions, which describe the representation and inheritance for each class
    
    2. special helper functions for defining generics and methods.
    
  * S4 also has multiple dispatch, which means that generic functions can pick methods based on the class of any number of arguments, not just one.
  
  3. Reference classes
  
  * called RC for short, are quite different from S3 and S4.
  
  * RC implements message-passing OO so methods belong to classes, not functions.
  
  * $ is used to separate objects and methods, so method calls look like canvas$drawRect("blue").
  
  * RC objects are also mutable: they don’t use R’s usual copy-on-modify semantics, but are modified in place.
  
  * This makes them harder to reason about, but allows them to solve problems that are difficult to solve with S3 or S4.

  4. Base Types
  
  * Base types are mostly manipulated using C code
  
  * they’re important to know about because they provide the building blocks for the other OO systems.


* You’ll learn how to recognise the OO system that an object belongs to, how method dispatch works, and how to create new objects, classes, generics, and methods for that system. The chapter concludes with a few remarks on when to use each system.

### 7.1 Base Types

* Underlying every R object is a C structure (or struct) that describes how that object is stored in memory

* The struct (C structure) includes the contents of the object, the information needed for memory management, and, most importantly for this section, a type.

* This is the base type of an R object. Base types are not really an object system because only the R core team can create new types.

* e.g. of base types : atomic vector, is function such as is.integer(), isfunction(), is primitive() etc.

* To see if an object is a pure base type : i.e., it doesn’t also have S3, S4, or RC behaviour, check that is.object(x)

```{r check is it base types, include=FALSE}
x <- c(1:10)

is.object(x)
#> [1] FALSE
# FALSE means x is a base types object

f <- function (x,y,z) {
  x^2 + y/2 + z+1 
}

f(10,11,12)
is.object(f)
#> [1] FALSE


```
### 7.2 S3

* S3 is R’s first and simplest OO system.

* it’s the most commonly used system in CRAN packages.

#### 7.2.1 Recognising objects, generic functions, and methods

* Most objects that you encounter are S3 objects.

* The closest way to check whether S3 object : you can come is is.object(x) &!isS4(x), i.e., it’s an object, but not S4. 

* An easier way is to use pryr::otype():

```{r check object type, include=FALSE}
install.packages('pryr')
library(pryr)

x <- 1:10

pryr::otype(x)
#> [1] "base"

df1 <- data.frame(a = 1:5, b = letters[6:10])
otype(df1)
#> [1] "S3"

class(df1)
#> [1] "data.frame"

otype(df1$a)
#> [1] "base" -> this means vector isnt S3 object

otype(df1$b)
#> [1] "base" -> this means character isnt S3 object

otype(as.factor(df1$b))
#> [1] "S3" -> this means factor is S3 object
```

* In S3, methods belong to functions, called generic functions, or generics
for short. S3 methods do not belong to objects or classes.















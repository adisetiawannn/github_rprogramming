---
title: "ADVANCED R"
author: "M Adi Setiawan"
date: "2023-09-15"
output: html_document
---

> disclaimer : this article adopt from advanced r by Hadley Wickham



# 1. DATA STRCUTURE

There are 3 common data type that be used in data analys framework :

1. Homogenous Data : Atomic Vector, Matrix & n Array

2. Heterogenous Data : List, Data Frame

## 1.1 Vector

Three common properties in vector : 
  * typeof() : what it is
  
  * length() : how many elements it contains
  
  * attributes() : additional arbitrary metadata
  
  > all elements of an atomic vector must be the same type, whereas the elements of a list can have different types.
  
  > NB: is.vector() does not test if an object is a vector. Instead it returns TRUE only if the object is a vector with no attributes apart from names. Use is.atomic(x) || is.list(x) to test if an object is actually a vector.
  
  
### 1.1.1 ATOMIC VECTOR

Atomic vectors are usually created with c(), short for combine:

```{r atomic vector, include=FALSE}
dbl_var <- c(1, 2.5, 4.5)

# With the L suffix, you get an integer rather than a double 
int_var <- c(1L, 6L, 10L)

# Use TRUE and FALSE (or T and F) to create logical vectors 
log_var <- c(TRUE, FALSE, T, F)

chr_var <- c("these are", "some strings")

# Atomic vectors are always flat, even if you nest c()’s:
c(1, c(2, c(3, 4)))

# [1]1234
```


NA will always be coerced to the correct type if used inside c(), or you can create NAs of a specific type with : 

  * NA_real_ (a double vector) 
  * NA_integer_ 
  * NA_character_
  
(you can check through combining it with typeof() function)

### 1.1.1.1 Types and tests

Given a vector, you can determine its type with typeof(), or check if it’s a specific type with an “is” function: is.character(), is.double(), is.integer(), is.logical(), or, more generally, is.atomic().

> is.numeric() is a general test for the “numberliness” of a vector and returns TRUE for both integer and double vectors. It is not a specific test for double vectors, which are often called numeric.

```{r type test, include=FALSE}

typeof(int_var)
is.integer(int_var)
is.atomic(int_var)

typeof(dbl_var)
is.double(dbl_var)
is.atomic(dbl_var)

is.numeric(int_var)
is.numeric(dbl_var)

# NB : Numeric contain 2 type : integer : whole number (ex : 1,10) and double : possibly store decimal (ex : 1.11 , 2.00)

```

### 1.1.1.2 Coercion

All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type.

```{r coercion vector, include=FALSE}

str(c("a", 1))
#>  chr [1:2] "a" "1" : stored as char

```

When a logical vector is coerced to an integer or double, TRUE becomes 1 and FALSE becomes 0. This is very useful in conjunction with sum() and mean().

```{r, include=FALSE}
x <- c(FALSE, FALSE, TRUE)
as.numeric(x)
str(as.numeric(x))

# so we can apply some basic math operating :

# Total number of TRUEs
sum(x) 
#>[1]1

# Proportion that are TRUE
mean(x)
#> [1] 0.3333

```

Coercion often happens automatically. Most mathematical functions (+, log, abs, etc.) will coerce to a double or integer, and most logical operations (&, |, any, etc) will coerce to a logical. You will usually get a warning message if the coercion might lose information. If confusion is likely, explicitly coerce with as.character(), as.double(), as.integer(), or as.logical().

### 1.1.2 List

Lists are different from atomic vectors because their elements can be of any type, including lists. You construct lists by using list() instead of c():

```{r list, include=FALSE}
x1 <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))

str(x1)

```

Lists are sometimes called recursive vectors, because a list can con- tain other lists. This makes them fundamentally different from atomic vectors.

```{r recursive vector, include=FALSE}

x2 <- list(list(list(list()))) 

str(x2)

#>Listof1
#> $ :List of 1
#>   ..$ :List of 1
#>   .. ..$ : list()

is.recursive(x2)
#> [1] TRUE
```

c() will combine several lists into one. If given a combination of atomic vectors and lists, c() will coerce the vectors to list before combining them. Compare the results of list() and c():

```{r combination of atomic vector and list, include=FALSE}

x3 <- list(list(1, 2), c(3, 4)) 
str(x3)
#> List of 2
#> $ :List of 2
#> ..$ : num 1
#> ..$ : num 2
#> $ : num [1:2] 3 4


y <- c(list(1, 2), c(3, 4)) 
str(y)

```

The typeof() a list is list. You can test for a list with is.list() and coerce to a list with as.list(). You can turn a list into an atomic vector with unlist(). If the elements of a list have different types, unlist() uses the same coercion rules as c().

## 1.2 Atrributes

* All objects can have arbitrary additional attributes, used to store meta data about the object.

* Attributes can be thought of as a named list (with unique names)

* Attributes can be accessed : 
  
  *individually with : attr()

  * all at once (as a list) with : attributes().

```{r attr and attributes, include=FALSE}
y2 <- 1:10

attr(y2, "my_attribute") <- "This is a vector" 

attr(y2, "my_attribute")
#> [1] "This is a vector"

str(attributes(y2))
#>Listof1
#> $ my_attribute: chr "This is a vector"

```

The only attributes not lost are the three most important:

  * Names, a character vector giving each element a name
  
  * Dimensions, used to turn vectors into matrices and arrays
  
  * Class,used to implement the S3 object system

Each of these attributes has a specific accessor function to get and set values. When working with these attributes, use names(x), class(x), and dim(x), not attr(x, "names"), attr(x, "class"), and attr(x, "dim").

### 1.2.1 Names

* You can name a vector in three ways: (function : names () and setnames () )

  1.  When creating it: x<-c(a=1,b=2,c=3).

  2. By modifying an existing vector in place: x <- 1:3; names(x) <- c("a", "b", "c").
  
  3. By creating a modified copy of a vector: x <- setNames(1:3, c("a", "b", "c")).

Not all elements of a vector need to have a name. If some names are missing, names() will return an empty string for those elements. If all names are missing, names() will return NULL.

```{r names, include=FALSE}

y3 <- c(a=1,2,3)
names(y3)

# or this setNames(y3, c('a'))

#> [1] "a" "" ""

z<-c(1,2,3)
names(z)
#> NULL

```

### 1.2.2 Factors

* One important use of attributes is to define factors. 

* A factor is a vector that can contain only predefined values, and is used to store categorical data. 

* Factors are built on top of integer vectors using two attributes :
  
  1. the class(), “factor”, which makes them behave differently from regular integer vectors.
  
  2. the levels(), which defines the set of allowed values.

> common function used on factor : factor (), class (), levels()

```{r factor, include=FALSE}

x1 <- factor(c("a", "b", "b", "a"))
x1
#>[1]abba
#> Levels: a b
class (x1)
#> [1] "factor"
levels(x1)
#> [1] "a" "b"

# You can't use values that are not in the levels
x1[2] <- "c"
#> Warning: invalid factor level, NA generated
x1
#>[1]a <NA>b a
#> Levels: a b

```

Factors are useful when you know the possible values a variable may take, even if you don’t see all values in a given dataset. Using a factor instead of a character vector makes it obvious when some groups contain no observations:

```{r factor case, include=FALSE}
sex_char <- c("m", "m", "m")
sex_factor <- factor(sex_char, levels = c("m", "f"))
table(sex_char) 
#> sex_char
#>m
#>3 table(sex_factor) 
#> sex_factor 
#>m f
#>3 0
```

* Sometimes when a data frame is read directly from a file, a column you’d thought would produce a numeric vector instead produces a factor. 

* This is caused by a non-numeric value in the column, often a missing value encoded in a special way like . or -. 

* To remedy the situation :

  1. coerce the vector from a factor to a character vector
  
  2. and then from a character to a double vector. 
  
* Be sure to check for missing values after this process.
  
* of course, a much better plan is to discover what caused the problem in the first place and fix that ; using the na.strings argument to read.csv() is often a good place to start.

```{r fixing factor while read data from csv, include=FALSE}

z1 <- read.csv(text = "value\n12\n1\n.\n9")

typeof(z1$value)
#> [1] "integer"

as.double(z1$value)
#>[1]3214
# Oops, that's not right: 3 2 1 4 are the levels of a factor, # not the values we read in!

class(z1$value)
#> [1] "factor"

#Wecanfixitnow:
as.double(as.character(z1$value))

#> Warning: NAs introduced by coercion
#>[1]12 1NA 9

# Or change how we read it in:
z1 <- read.csv(text = "value\n12\n1\n.\n9", na.strings=".") 
typeof(z1$value)
#> [1] "integer"

class(z1$value)
#> [1] "integer" z$value
#>[1]12 1NA 9 # Perfect! :)
```

While factors look (and often behave) like character vectors, they are actually integers. Be careful when treating them like strings. Some string methods (like gsub() and grepl()) will coerce factors to strings, while others (like nchar()) will throw an error, and still others (like c()) will use the underlying integer values. For this reason, it’s usually best to explicitly convert factors to character vectors if you need string-like behaviour. In early versions of R, there was a memory advantage to using factors instead of character vectors, but this is no longer the case.

## 1.3 Matrices and Array

* Common function that used to be on matrix and array 

|                         |  matrix                 | array             |
|:------------------------|:-----------------------:|:-----------------:|
|structure                |two dimensions           |Multidimensional   |
|Assignment form          |matrix(),dim()           |array(),dim()      |
|length (ndata)           |length()                 |length()           |
|nrow                     |nrow(),ncol()            |dim()              |
|assigning row & col name |rownames(),colnames()    |dimnames()         |
|binding data             |rbind(),cbind()          |abind()            |
|check matrix or array    |is.matrix()              |is.array()         |
|assign as                |as.matrix()              |as.array()         |
|matrix transpose         |t()                      |t()                |

```{r matrix and array, include=FALSE}

# create matrix and array
matrix_a <-  matrix(data = seq (1,6,1), nrow = 2, ncol = 3)
array_a <-  array(1:6, dim = c(2,3,2)  ) # dim = c (row,col,list no)

# or we can use dim to convert existing object to matrix and array
a <- 1:6
# creating matrix with dim()
dim(a) <- c(2,3)
a

# creating array with dim ()
dim(a) <- c(2,3,1)
a

# view matrix and array structure
dim(matrix_a) # or
dim (array_a)

# view length of whole data (ndata)
length (matrix_a)
length (array_a)

# view length of row data or col (nrow or ncol)

# on matrix and array
nrow(matrix_a)
ncol (array_a)


# assign names of row and col (for indexing row and col) of matrix and array
# for matrix, use rownames() and colnames()
rownames(matrix_a) <- c("a","b")
colnames(matrix_a) <- c("c","d", "e")
matrix_a

# for array, use dimnames()

dimnames(array_a) <- list(c("a","b"), c("c",'d','e'), c('A','B'))
array_a

array_a["A"]

```


```{r binding then check then assign as, include=FALSE}
add_b <- seq (7,12,1)
dim (add_b) <- c(2,3)

rbind(matrix_a, add_b)

# check is it matrix ?
is.matrix(array_a)

# check is it array ?
is.array(matrix_a)

# assign as matrix

as.matrix(add_b)
is.matrix(add_b)


# transpose matrix

t(add_b)

```

> Vectors are not the only 1-dimensional data structure. You can have matrices with a single row or single column, or arrays with a single. see the differences with str () function.


## 1.4 data Frame

data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list.

|                         |  Dataframe              | 
|:------------------------|:-----------------------:|
|structure                |two dimensions           |
|Assignment form          |data.frame()             |
|length (ndata)           |length()                 |
|nrow                     |nrow(),ncol()            |
|assigning row & col name |rownames(),colnames()    |
|binding data             |rbind(),cbind()          |
|check matrix or array    |is.data.frame()          |
|assign as                |as.data.frame()          |
|transpose                |t()                      |




```{r dataframe, include=FALSE}

# create a dataframe
x <- data.frame(x = seq(1,3,1), y = c('a','b','c'))
str(x)

```


### 1.4.1 Testing & Coercion

* Because a data.frame is an S3 class, its type reflects the underlying vector used to build it : the list. 

* To check if an object is a data frame, use class() or test explicitly with is.data.frame()

* to coerce a data frame use as.data.frame ()
  
  * A vector will create a one-column data frame.
  
  * A list will create one column for each element; it’s an error if they’re
not all the same length.
  
  * A matrix will create a data frame with the same number of columns and rows.

```{r test & coercion data.frame, include=FALSE}
# TESTING

typeof(x)
#> "list"

class (x)
#> "data.frame"

is.data.frame(x)
#> TRUE


## COERCE : you can coerce an object to data frame with : as.data.frame ()

y <- c("x" = c(1,2,3),
       "y" = c('a','b','c'))
class(y)

#> "character"

y1 <- as.data.frame(y)
class(y1)
#> "data.frame"

```


### 1.4.2 Combining Data Frames

* we can combine a data frame using cbind() and row cbind() :

```{r cbind, include=FALSE}
cbind(x, z=c(3:1))

rbind(x, z = c(3:2))


```

Key take away of bind row and column of dataframe :

* When combining column-wise, the number of rows must match, but row names are ignored.

* When combining row-wise, both the number and names of columns must match

* Use "plyr::rbind.fill()" to combine data frames that don’t have the same columns.

* avoid bind a factor data type.

> The conversion rules for cbind() are complicated and best avoided by ensuring all inputs are of the same type.

### 1.4.3 Special Columns

* Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list

```{r special column, include=FALSE}

df <- data.frame(x = 1:3)
y <- list(1:2, 1:3, 1:4)

# list add as whole in single cell ()
df$y <- y
df [2]

# it tries to put each item of the list into its own column

# data.frame(x = 1:3, y = list(1:2, 1:3, 1:4))
#> arguments imply differing number of rows: 2, 3, 4

# A workaround is to use I(), which causes data.frame() to treat the list as one unit:

# I () stand for : Change the class of an object to indicate that it should be treated ‘as is’.
df1 <- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4)))
str(df1)
df1[2]

```

* Similarly, it’s also possible to have a column of a data frame that’s a matrix or array, as long as the number of rows matches the data frame:

```{r dataframe combined matrix, include=FALSE}
df2 <- data.frame(x = 1:3, 
                  y = I(matrix(data = seq(1,6,1), ncol = 2, nrow = 3)))

str(df2)
df2[2,'y']

```

## 2 SUBSETTING

* The three subsetting operators.

* The six types of subsetting.

* Important differences in behaviour for different objects (e.g., vectors, lists, factors, matrices, and data frames).

* The use of subsetting in conjunction with assignment.

* subsetting operators : [], [[]], $

### 2.1 Subsetting atomic vector

* There are five things that you can use to subset a vector :
  
  1. positive integers : return elements at the specified positions
  
  2. negative integers : omit elements at the specified positions (You can’t mix positive and negative integers in a single subset)
  
  3. Logical: select elements where the corresponding logical value is TRUE
  
  4. NULL ([]) : returns the original vector
  
  5. Zero : Zero returns a zero-length vector. usually used in test data.
  
  6. Character : return elements with matching names

```{r subsetting atomic vector, include=FALSE}
x1 <- seq (1,10,1)

# 1. positive integers : return element in spesific positions
x1 [4:8]
#> [1] 4 5 6 7 8

x1 [c(10,2,6)]
#> [1] 10  2  6

# Duplicated indices yield duplicated values
x1[c(2, 2)]
#> [1] 2 2

# Real numbers are silently truncated to integers
x1[c(2.1, 2.9)]
#> [1] 2 2

# 2. negative integers : omit/remove element in spesific positions

x1 [-1]
#> [1]  2  3  4  5  6  7  8  9 10


x1 [c(-2,-10)]
#> [1]  1  3  4  5  6  7  8  9 

# You can’t mix positive and negative integers in a single subset

# x1[c(-1, 2)]
#> Error in x1[c(-1, 2)] : only 0's may be mixed with negative subscripts

# 3. Logical Vector : return element on TRUE logical positions

x1 [c(T,F,T,F)] # TRUE stand for odd number (angka ganjil)
#> [1] 1 3 5 7 9

# If the logical vector is shorter than the vector being subsetted, it will be recycled to be the same length.

# above equivalent as below :
x1 [c(T,F)]
#> [1] 1 3 5 7 9

#> [1] 1 3 5 7 9
x1 [x1>3]
#> [1]  4  5  6  7  8  9 10

x1 [x1%%2 == 0] # return whole number (angka genap)
#> [1]  2  4  6  8 10

# A missing value in the index always yields a missing value in the output:
x1 [c(T,F,NA,T)]
#> [1]  1 NA  4  5 NA  8  9

# 4. Nothing : return the orignal vector

x1 []
#> 1  2  3  4  5  6  7  8  9 10

# 5. Zero : Zero returns a zero-length vector
x1[0]
#> numeric(0)

x2 <- c('a','b','c')
x2 [0]
#> character(0)

# 6. Character Vector : return elements with matching names

y<- setNames(object = x1, letters[1:10])

y[c('a','j','d')]
#>  a  j  d 
#>  1 10  4 

# Like integer indices, you can repeat indices
y[c('e','e','e')]
#>  e  e  e 
#>  5  5  5  

# When subsetting with [ names are always matched exactly. if any match it will return NA

z <- c('abc' = 1, 'def'=2)
z [c('a','d')]
#> <NA> <NA> 
#>  NA   NA

z[c('abc','def')]
#> abc def 
#> 1   2 



```

### 2.2 Subsetting List

* Subsetting a list works in the same way as subsetting an atomic vector.

### 2.3 Matrices and Arrays

* You can subset higher-dimensional structures in three ways :
  
  1. With multiple vectors.
  
  2. With a single vector.
  
  3. With a matrix.

* subsetting in list in general : supply a 1d index for each dimension, separated by a comma

* Blank subsetting is now useful, because it lets you keep all rows or all columns

* on subsetting arrays, we can do with matrix : 2d matrix for 2d array or matrix, 3d matrix for 3d array and so on. Each row in the matrix specifies the location of one value

```{r subsetting matrix and array, include=FALSE}

# subsetting matrix

a <- matrix (data=1:9, nrow = 3)
colnames(a) <- LETTERS[1:3]

# basic subsetting on list -< [row,col]

a [2,1]
a [c(T,F,T), c(T,T,F)]
a [c(-2), c("C","B")]

b <- outer(1:5, 1:5, FUN = "paste", sep = ",")
b [c(9,15)]

select <- matrix(ncol = 3, byrow = TRUE, data = paste (c(1,3,2),c(1,1,4), 
                                                       sep = ","))

b [select]
#> [1] "1,1" "3,1" "2,4"

```


### 2.4 Data Frames

* Data frames possess the characteristics of both lists and matrices : if you subset with a single vector, they behave like lists; if you subset with two vectors, they behave like matrices.

```{r subsetting data frame, include=FALSE}

df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

# basic subsetting data frame -> [row, col]

df[df$x == 2, ]

df[c(1, 3), ]

# Like a list:
df[c("x", "z")] 
#> xz #>11a #>22b #>33c
# Like a matrix
df[, c("x", "z")] 
#> xz #>11a #>22b #>33c

# There's an important difference if you select a single column: matrix subsetting simplifies by default (same datastructure as data frame), list subsetting does not.

# as matrix
str(df["x"])
#> 'data.frame': #> $x:int 123 

# as list
str(df[, "x"])
#> int[1:3]123
```

### 2.5 S3 objects

* S3 objects are made up of atomic vectors, arrays, and lists.
* so you can always pull apart an S3 object using the techniques described above and the knowledge you gain from str().

### 2.6 S4 objects

* There are also two additional subsetting operators that are needed for S4 objects : 
  1. @ (equivalent to $).
  2. slot() (equivalent to [[). 
  
* @ is more restrictive than $ in that it will return an error if the slot does not exist.

## 3 SUBSETTING OPERATORS

* there are 2 subsetting operator :
  
  * $ : is a shorthand operator, where x$y is equivalent to x[["y", exact = FALSE]]
  
  * [[]] : [[ is similar to [, except it can only return a single value and it allows you to pull pieces out of a list. 
  
  * You need [[ when working with lists. This is because when [ is applied to a list it always returns a list: it never gives you the contents of the list. To get the contents, you need [[ . Because it can return only a single value, you must use [[ with either a single positive integer or a string:
  
```{r [[ operator, include=FALSE}
a<-list(a=c(1,2,3) ,b=c(4,5,6))

a [2]
str(a[2])
#> return list of b : [1] 4 5 6
#> List of 1
#> $ b: num [1:3] 4 5 6

a[["b"]]
#> return list of b : [1] 4 5 6
str(a[[2]])
#> num [1:3] 4 5 6

# If you do supply a vector it indexes recursively
b <- list(a = list(b = list(c = list(d = 1)))) 
b[[c("a", "b", "c", "d")]]
#>[1]1

# Same as
b[["a"]][["b"]][["c"]][["d"]] 
#>[1]1
# Because data frames are lists of columns, you can use [[ to extract a column from data frames

mtcars[[1]]
mtcars[["cyl"]]

```
  
### 3.1 Simplifying vs. preserving subsetting

* Simplifying subsets returns the simplest possible data structure that can represent the output. (output often as vector/list (changed from initial) )

* Preserving subsetting keeps the structure of the output the same as the input (remain initial data structure)
  
|                         |  Simplifying            | Preserving                  |
|:------------------------|:-----------------------:|:---------------------------:|
|Vector                   |x[[1]]                   |x[1]                         |
|list                     |x[[1]]                   |x[1]                         |
|factor                   |x[1:4, drop = T]         |x[1:4]                       |
|Array                    |x[1,] or x[,1]           |x[1,,drop=F] or x[,1,drop=F] |
|Data Frame               |x[,1] or x[[1]]          |x[,1,drop=F] or x[1]         |


> Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below.

```{r simplifying and preserving, include=FALSE}
# 1.  Atomic vector: simplifying will removes names.
x<-c(a=1,b=2) 

# preserving
x[1]
#>a
#>1

class(x[1])
#> [1] "numeric"

# simplifying

x[[1]] 
#>[1]1 -> names be removed

class(x[[1]])
#> "numeric"

# 2. List : preserving return the object inside the list, not a single element list. simplifying will reccursive output and change structure and removes names.

y<-list(a=c(1,2,3),b=c(4,5,6))

# preserving
str(y[1])
#> List of 1
#> $ a: num [1:3] 1 2 3

# simplifying
str(y[[2]])
#>  num [1:3] 4 5 6
class (y[[2]])
#> [1] "numeric"

#. 3 Factor : drops any unused levels.

z <- factor(c("a", "b"))

# preserving
z [1]
#> [1] a
#> Levels: a b

# simpifying
z [1, drop = T]
#> [1] a
#> Levels: a

# 4. Matrix or array: if any of the dimensions has length 1, drops that dimension.

a1 <- matrix(1:4, nrow = 2)

# preserving
a1[1, , drop = FALSE]
#>      [,1] [,2]
#> [1,]    1    3
class(a1[1, , drop = FALSE])
#> [1] "matrix" "array" 

# simpifying
a1 [1,]
#> [1] 1 3
class (a1[1,])
#> [1] "integer"

# 5. Data frame : if output is a single column, returns a vector instead of a data frame.

# preserving

df <- data.frame(a = 1:2, b = 1:2) 
str(df[1])
str(df[, "a", drop = FALSE])
# data structure remains as data frame

# simplifying

str(df[[1]])
str(df[,'a'])
# data structure changed as vector

```

### 3.2 Dollar sign ($)

* $ is a shorthand operator, where x$y is equivalent to x[["y", exact = FALSE]] : simplifying

* One common mistake with $ is to try and use it when you have the name of a column stored in a variable

* There’s one important difference between $ and [[. $ does partial matching

```{r common mistake using $, include=FALSE}

# One common mistake with $ is to try and use it when you have the name of a column stored in a variable

mtcars

var <- "cyl" # cyc is one of column name at mtcars data

mtcars$var
#> NULL
#> # Doesn't work - mtcars$var translated to mtcars[["var"]]

# instead use [[]] or []

mtcars[var]
mtcars[[var]]
```


```{r partial matching $ and [[]], include=FALSE}
x <- list (abc = c(1,2,3,4))

# it return same output
x$a
# equivalent
x$ab
# equivalent
x$abc
#> [1] 1 2 3 4

x[["ab"]]
#> NULL

```


### 3.3 Missing/out of bounds indices

* [ and [[ differ slightly in their behaviour when the index is out of bounds (OOB).

* The following table summarises the results of subsetting atomic vectors and lists with [ and [[ and different types of OOB value.

| Operator   | Index       | Atomic     | List        |
|:----------:|:-----------:|:----------:|:-----------:|
| [          | OOB         | NA         | list(NULL)  |
| [          | NA_real_    | NA         | list(NULL)  |
| [          | NULL        | x[0]       | list(NULL)  |
| [[         | OOB         | Error      | Error       |
| [[         | NA_real_    | Error      | NULL        |
| [[         | NULL        | Error      | Error       |

```{r missing/out of bounds, include=FALSE}
x<-1:4
x1 <- list(1:4)
x[5]
#> [1] NA
x1[2]

x1[[NA_real_]]
```

### 3.4. Subsetting & Assignment

* All subsetting operators can be combined with assignment to modify selected values of the input vector.

```{r subsetting & assignment, include=FALSE}
x <- c(1:5)

x[c(3,5)] <- c(10,20)
#> [1]  1  2 10  4 20

# The length of the LHS needs to match the RHS
x [c(-1,-2)] < 4:1
# length doesnt match, so it return an error

x [-1] <- 4:1
#> [1] 1 4 3 2 1
#> Note that there's no checking for duplicate indices

# You can't combine integer indices with NA

x[c(1, NA)] <- c(1, 2)

#> Error in x[c(1, NA)] <- c(1, 2) : 
#> NAs are not allowed in subscripted assignments

# But you can combine logical indices with NA
# (where they're treated as false).
x[c(T, F, NA)] <- 1
x
#> [1] 1 4 3 1 1

# This is mostly useful when conditionally modifying vectors
df <- data.frame(x = c(1,NA,3,4,5),
                 y = c(6,7,8,NA,10))

df$x [df$y <= 7]
#> [1]  6  7 NA
#> NA will be kept, no matter T or F and it will return NA too.
#> logical operator will return T or F,then subsetting will logically behave

```

### 3.5 Applications

#### 3.5.1 Lookup Tables (Character Subsetting)

Character matching provides a powerful way to make lookup tables. 

```{r lookup tables, include=FALSE}

# for lookup, keep in my behaviour of subsetting : positive integer, negative integer, character, NULL, ZERO and logical. also, behaviour of data type :vector, list, array etc

x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female", u = NA)

lookup[x] # artinya ambil data lookup sesuai data susunan data x

# remove names
unname(lookup[x])

x1 <- c(1,2,3,4)
y1 <- c(T,F,T,F)

x1 [y1] # ambil data x1 sesuai dengan var y1


x2 <- -2
x1 [x2]


# lookup in data frame
df1 = data.frame(gender = c('m','m','f'),
                 score = c(10,9,11))

df1$gender <- lookup[df1[,1]]

# or
df2 = data.frame(gender = c('m','m','f'),
                 score = c(10,9,11))

lookup[df2$gender]

```

#### 3.5.2 Matching and Merging by Hand (Integer subsetting)

* You may have a more complicated lookup table which has multiple columns of information


```{r matching and merging on multiple column, include=FALSE}

x <- c(1, 2, 2, 3, 1)


df <- data.frame(grade = 3:1,
                 desc = c("Excellent","Good", "Poor"),
                 fail = c(F, F, T))
# 1. with match
# define id lookup
id <- match (x = x,table =  df[,"grade"])
df [id,]

#2. with rownames()
rownames(df) # from this we know, that row names is character, so convert x as char to return df data as x values

df [as.character (x), ]

# 3. basic subsetting
# or you can do manually with basic lookup subsetting
df [df$grade[x],] # ambil data df sesuai dengan posisi df$grade berdasarkan x


```

> If you have multiple columns to match on, you’ll need to first collapse them to a single column (with interaction(), paste(), or plyr::id()). You can also use merge() or plyr::join(), which do the same thing for you — read the source code to see how.

#### 3.5.3 Random Samples / Bootstrap (Integer Subsetting)

* You can use integer indices to perform random sampling or bootstrap- ping of a vector or data frame.

* sample() generates a vector of indices, then subsetting to access the values

```{r random samples (bootstraping), include=FALSE}
df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])

# basic bootstraping
df [sample(nrow(df)),]

# boostraping 3 rows
df [sample(nrow(df), 3), ]

# boostraping with replicate/duplicate value indices
df [sample(nrow(df), replace = TRUE), ]


```

#### 3.5.4 Ordering (integer subsetting)

* order() takes a vector as input and returns an integer vector describing how the subsetted vector should be ordered (mengurutkan posisinya)

* For two or more dimensions, order() and integer subsetting makes it easy to order either the rows or columns of an object

```{r ordering subsetting, include=FALSE}

x <- c ("c","b",'a')

order (x)
#> [1] 3 2 1 -> urutan c b a dalam abjad.

x [order(x)]
#> [1] "a" "b" "c"

random_sample <- sample (10)
random_sample[order(random_sample)]

# order two dimension or more with order subsetting

df <- data.frame(x = rep(1:3, each = 2), y = 6:1, z = letters[1:6])


# ordering row 
df [order(df[['y']]), ]

df [order(df$z),]

# ordering col
df [, order(names(df))]

```

> More concise, but less flexible, functions are available for sorting vectors, sort(), and data frames, plyr::arrange().

#### 3.5.5 Expanding aggregated counts (integer subsetting)

* Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. 

* rep() and integer subsetting make it easy to uncollapse the data by subsetting with a repeated row index.

```{r Expanding aggregated counts, include=FALSE}
df2 <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

rep(1:nrow(df2), df2$n)
#> [1] 1 1 1 2 2 2 2 2 3

df2[rep(1:nrow(df2), df2$n), ]
```

#### 3.5.6 Removing columns from data frames (character subsetting)

* There are two ways to remove columns from a data frame : 
  1. You can set individual columns to NULL
  
  2. you can subset to return only the columns you want
  
```{r Removing columns from data frames, include=FALSE}
df3 <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))

# 1. Removing columns from data frames
df3$y <- NULL
df3

# 2.  subset to return only the columns you want
df3 [, c("x","n")]

# or
# combine with setdiff () function
df3 [, setdiff(names(df3), "x")] # remove column x

```


#### 3.5.7 Selecting rows based on a condition (logical subsetting)

* Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame



```{r Selecting rows and cols based on a condition, include=FALSE}
# selecting rows
mtcars [mtcars[['gear']],]
mtcars [mtcars[['gear']] == 5 & mtcars$cyl == 4,]

# selecting col
mtcars [ , names(mtcars) == "gear" | names(mtcars) == "cyl"  ]
```
> Remember to use the vector boolean operators & and |, not the shortcircuiting scalar operators && and || which are more useful inside if statements

1. & Operator adalah operator logis dan juga bitwise, karena beroperasi pada boolean maupun data biner, sedangkan operator && hanyalah operator logis karena hanya beroperasi pada tipe data boolean.

2. Operator & mengevaluasi kedua sisi ekspresi untuk mendapatkan hasil akhir sedangkan, operator && hanya mengevaluasi sisi kiri ekspresi & jika ternyata salah, ia bahkan tidak mengevaluasi sisi kanan ekspresi. 

```{r logical operator, include=FALSE}
a <- c(T,F,T,T)
b<- c(T,T,F,F)

# & operator : dia akan mengevaluasi sisi kiri dan kanan, return sesuai panjang kedua input.

a & b 
#> [1]  TRUE FALSE FALSE FALSE

# && operator : Ketika kita gunakan operator && pada a && b maka yang akan dievaluasi adalah elemen pertama dari a dan b


```


other logical operator :

* !(X & Y) is the same as !X | !Y

* !(X | Y) is the same as !X & !Y

* For example, !(X & !(Y | Z)) simplifies to !X | !!(Y|Z), and then to !X | Y | Z.

* subset() is a specialised shorthand function for subsetting data frames, and saves some typing because you don’t need to repeat the name of the data frame.

```{r subset functions, include=FALSE}
mtcars


# subset functions : subset (x, subset/logical conditions, select)
subset (x = mtcars, subset = cyl > 5, select = c(mpg,qsec))

# subset multiple columns
subset (mtcars, mpg <= 21 & am != 1 )

# or

subset (mtcars, !(mpg >= 21 | am == 1) ) # !X & !Y

```


#### 3.5.8 Boolean algebra vs. sets (logical & integer subsetting)

* It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). 

* Using set operations is more effective when :

  1. You want to find the first (or last) TRUE.
  
  2. You have very few TRUEs and very many FALSEs; a set representation may be faster and require less storage.

* which() allows you to convert a boolean representation to an integer representation.

```{r which function, include=FALSE}
x <- sample(100, 10)

which (x < 80)

x [which(x<80)]

# unwhich functions (manually defined)
 
unwhich <- function(x, n) {
   out <- rep_len(FALSE, n)
   out[x] <- TRUE
   out
}
unwhich(which(x < 80), 10)

```

Let’s create two logical vectors and their integer equivalents and then explore the relationship between boolean and set operations.

```{r create 2 logical vector and explore relationship between them , include=FALSE}
x1<-1:10%%2==0 # logical vector

x2 <- which(x1) # integer vector

y1<-1:10%%5==0 # logical vector
y2 <- which(y1) # integer vector


# explore relationship between vector
# 1. X & Y <-> intersect(x, y) for integer or which (x & y) for logical

x1 & y1
which (x1 & y1)

intersect (x2,y2)

# 2, #X|Y<->union(x,y)
union (x2, y2) # subset only return TRUE values

# 3. X & !Y <-> setdiff(x, y)
setdiff (x2,y2)

# 4. xor(X, Y) <-> setdiff(union(x, y), intersect(x, y)) #kebalikan x dan y

xor (x1, y1)

setdiff(union(x2, y2), intersect(x2, y2))


```


* key take a note :

  1. which () : switches from logical to integer subsetting
  
  2.  x[-which(y)] is not equivalent to x[!y] : if y is all FALSE, which(y) will be integer(0) and -integer(0) is still integer(0)
  
  3. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last TRUE value.
  
  
## 4 VOCABULARY


### 4.1 Basic

#### 4.1.1 The first functions to learn

* ? 

* str

#### 4.1.2 Important operators and assignment

* %in% : match returns a vector of the positions of (first) matches of its first argument in its second.

* match : match returns a vector of the positions of (first) matches of its first argument in its second. (same as %in%)

* =

* <-

* <<- : make a global scope var

* $, [, [[, head, tail

* subset : selecting / subsetting based on condition. subset (data, subset = condition)

* with : Evaluate an R expression in an environment constructed from data, possibly modifying (a copy of) the original data.

* assign : Assign a value to a name in an environment.

* get : search by name for an object (get) or zero or more objects (mget).

```{r operator and assignment vocab, include=FALSE}

# 1. %in%

x <- c(1,2,3,4,5,6)
y <- c(2,3,4)

5 %in% x
#> [1] TRUE

10 %in% x
#> [1] FALSE

x %in% y

# 2. subset : selecting / subsetting based on conditional 

subset (x, subset = y > 3) # subset y > 3 will return [3]. then [3] will used as index to get values from x

# 3. with 

# syntax : with(data-frame, R expression)

data_A <- data.frame(num =  c(100,100,100,100,100),
                     cost =c(1200,1300,1400,1500,1600))

with(data_A, num*cost)
with(data_A, cost/num)

# with juga bisa digunakan sebagai subsetting dengan conditional

with(data_A, num >= 100 & cost >= 1400)
#> [1] FALSE FALSE  TRUE  TRUE  TRUE 

# 4. Assign : Assign a value to a name in an environment.
# syntax : assign ("var name", value to be assigned)

x1 <- c(11,12,13,14)

assign ("x1 [3]",'aa')

# 5. get : search by name for an object (get) or zero or more objects (mget).

get ("x1 [3]")
#> [1] "aa"

```


#### 4.1.3 Comparison

* all.equal : Test if Two Objects are (Nearly) Equal

* identical : Test Objects for Exact Equality

* !=, ==, >, >=, <, <=

* is.na : The generic function is.na indicates which elements are missing.

* complete.cases : Return a logical vector indicating which cases are complete, i.e., have no missing values.

* is.finite & is.infinite : is.finite and is.infinite return a vector of the same length as x, indicating which elements are finite (not infinite and not missing) or infinite.

```{r comparison, include=FALSE}

# 1. all.equal () : Test if Two Objects are (Nearly) Equal

all.equal (11,11)
#> [1] TRUE

all.equal (11,11.5) 
#> "Mean relative difference: 0.04545455"

all.equal ("aaaa","abab")
#> [1] "1 string mismatch"


# 2. identical () : Test Objects for Exact Equality
identical (1,"1")
# [1] FALSE

identical (11,11)
# [1] TRUE

identical ("aaaa","aaaa")
#> [1] TRUE

identical ("aacc","cacaaa")
#> [1] FALSE


# 3. complete.cases() :  Return a logical vector indicating which cases are complete (is it TRUE or FALSE)

x <- airquality[, -1] # x is a regression design matrix
y <- airquality[,  1] # y is the corresponding response

x2 <- c(1,NA,3,NA)
y2 <- c(1,2,NA,NA)

complete.cases (x2)
#> [1]  TRUE FALSE  TRUE FALSE

complete.cases(x1,y1)

complete.cases(x2,y2)
#> [1]  TRUE FALSE FALSE FALSE


# 4. is.finite () & is.infinite

Inf # infinite

is.finite(Inf)
#> [1] FALSE

is.finite(1)
#> [1] TRUE

is.infinite(x2)
#> [1] FALSE FALSE FALSE FALSE

```

#### 4.1.4 Basic Math

* *, +, -, /, ^, %%, %/%

* abs, sign

* acos, asin, atan, atan2

* sin, cos, tan

* ceiling, floor, round, trunc, signif

* exp, log, log10, log2, sqrt


* max, min, prod, sum

* cummax, cummin, cumprod, cumsum, diff

* pmax, pmin

* range

* mean, median, cor, sd, var

* rle

     
#### 4.1.5 Functions to do with functions

* function

* missing : missing can be used to test whether a value was specified as an argument to a function.

* on.exit :  function is used to record a given function to be called when the present or current function exits.

* return

* invisible : Return a (temporarily) invisible copy of an object.



```{r functions to do functions, include=FALSE}
# functions

coba_function <- function(n,b) { n +b }
                           
coba_function(10,11)                          


# Missing Functions :  missing can be used to test whether a value was specified as an argument to a function.

coba_function2 <- function (x) { return (missing (x))}

coba_function2 ()
#> [1] TRUE

coba_function2(2)
#> [1] FALSE

coba_function3 <- function (x,y) { if (missing (x) == T) { 
  print ('argument x is missing')}
  else {print("nothing argument is missing")}
}


coba_function3(,y = 1)
#> [1] "argument x is missing"

# 3. on.exit :  function is used to record a given function to be called when the present or current function exits.

# syntax : on.exit(expr = NULL, add = FALSE, after = TRUE)


# =============== on.exit applications =======================

# creating functions
function_2 <- function() {
  # calling the on.exit() function 
  on.exit(print('function_two exited'));

  print('I am in function_two');
}

# creating another function 
function_1 <- function() {
  # calling the on.exit() function 
  on.exit(print('function_one exited'));

  print('I am in function_one and am going to call function_two');
  
  # calling functio_two
  function_2();
}

# calling the function_1
function_1()

# =============================================================


# 4. Invisible : Return a (temporarily) invisible copy of an object.

invisible(coba_function2())
#> 
```

#### 4.1.6 Logical & sets

* &,|,!,xor

* all : Given a set of logical vectors, are all of the values true?

* any : Given a set of logical vectors, are all of the values true?

* intersect : finds all rows in both x and y.

* union : finds all rows in either x or y, excluding duplicates.

* setdiff :setdiff(x, y) finds all rows in x that aren't in y.

* setequal :  returns TRUE if x and y contain the same rows (ignoring order).

* which : Give the TRUE indices of a logical object, allowing for array indices.


#### 4.1.7 Vectors and matrices

* c : create vector

* matrix : create matrix

#### 4.1.8 automatic coercion rules character > numeric > logical

* length, dim, ncol, nrow

* cbind, rbind : binding col or row

* names, colnames, rownames : get a index names or col names or row names

* t : transpose matrix

* diag : Extract or replace the diagonal of a matrix, or construct a diagonal matrix.

* sweep : Return an array obtained from an input array by sweeping out a summary statistic.

* as.matrix, data.matrix : convert data to matrix

#### 4.1.8 Making Vectors

* c

* rep, rep_len : rep replicates the values in x

* seq, seq_len, seq_along : Generate regular sequences

* rev : rev provides a reversed version of its argument. It is generic function with a default method for vectors and one for dendrograms.

* sample :sample takes a sample of the specified size from the elements of x using either with or without replacement

* choose, factorial, combn (is/as).(character/numeric/logical/...)

#### 4.1.9 Lists & data.frames
* list, unlist

* data.frame, as.data.frame

* split : split divides the data in the vector x into the groups defined by f

* expand.grid : Create a data frame from all combinations of the supplied vectors or factors

#### 4.1.10 Control flow

if, &&, || (short circuiting)

for, while

next, break

switch

ifelse

#### 4.1,11 Apply & friends

* lapply, sapply, vapply

* apply

* tapply

* replicate


